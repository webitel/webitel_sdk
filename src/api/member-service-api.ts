// tslint:disable
/**
 * Webitel API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 24.04.0
 * Contact: support@webitel.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
import { Configuration } from '../configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base'
// @ts-ignore
import { EngineApiError } from '../api'
// @ts-ignore
import { EngineAttemptCallbackRequest } from '../api'
// @ts-ignore
import { EngineAttemptRenewalResultRequest } from '../api'
// @ts-ignore
import { EngineAttemptResultRequest } from '../api'
// @ts-ignore
import { EngineAttemptResultResponse } from '../api'
// @ts-ignore
import { EngineCreateAttemptRequest } from '../api'
// @ts-ignore
import { EngineCreateAttemptResponse } from '../api'
// @ts-ignore
import { EngineCreateMemberBulkRequest } from '../api'
// @ts-ignore
import { EngineCreateMemberRequest } from '../api'
// @ts-ignore
import { EngineDeleteMembersRequest } from '../api'
// @ts-ignore
import { EngineListAttempt } from '../api'
// @ts-ignore
import { EngineListHistoryAttempt } from '../api'
// @ts-ignore
import { EngineListMember } from '../api'
// @ts-ignore
import { EngineListMemberAttempt } from '../api'
// @ts-ignore
import { EngineMemberBulkResponse } from '../api'
// @ts-ignore
import { EngineMemberInQueue } from '../api'
// @ts-ignore
import { EnginePatchMemberRequest } from '../api'
// @ts-ignore
import { EngineResetMembersRequest } from '../api'
// @ts-ignore
import { EngineResetMembersResponse } from '../api'
// @ts-ignore
import { EngineUpdateMemberRequest } from '../api'
/**
 * MemberServiceApi - axios parameter creator
 * @export
 */
export const MemberServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} attemptId
     * @param {EngineAttemptCallbackRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attemptCallback: async (
      attemptId: string,
      body: EngineAttemptCallbackRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'attemptId' is not null or undefined
      if (attemptId === null || attemptId === undefined) {
        throw new RequiredError(
          'attemptId',
          'Required parameter attemptId was null or undefined when calling attemptCallback.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling attemptCallback.'
        )
      }
      const localVarPath = `/call_center/attempts/{attempt_id}`.replace(
        `{${'attempt_id'}}`,
        encodeURIComponent(String(attemptId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} queueId
     * @param {string} memberId
     * @param {string} attemptId
     * @param {EngineAttemptResultRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attemptResult: async (
      queueId: number,
      memberId: string,
      attemptId: string,
      body: EngineAttemptResultRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling attemptResult.'
        )
      }
      // verify required parameter 'memberId' is not null or undefined
      if (memberId === null || memberId === undefined) {
        throw new RequiredError(
          'memberId',
          'Required parameter memberId was null or undefined when calling attemptResult.'
        )
      }
      // verify required parameter 'attemptId' is not null or undefined
      if (attemptId === null || attemptId === undefined) {
        throw new RequiredError(
          'attemptId',
          'Required parameter attemptId was null or undefined when calling attemptResult.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling attemptResult.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{member_id}/attempts/{attempt_id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'member_id'}}`, encodeURIComponent(String(memberId)))
        .replace(`{${'attempt_id'}}`, encodeURIComponent(String(attemptId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} attemptId
     * @param {EngineAttemptRenewalResultRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attemptsRenewalResult: async (
      attemptId: string,
      body: EngineAttemptRenewalResultRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'attemptId' is not null or undefined
      if (attemptId === null || attemptId === undefined) {
        throw new RequiredError(
          'attemptId',
          'Required parameter attemptId was null or undefined when calling attemptsRenewalResult.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling attemptsRenewalResult.'
        )
      }
      const localVarPath = `/call_center/queues/attempts/{attempt_id}/renewal`.replace(
        `{${'attempt_id'}}`,
        encodeURIComponent(String(attemptId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Offline queue
     * @param {string} queueId
     * @param {string} memberId
     * @param {EngineCreateAttemptRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttempt: async (
      queueId: string,
      memberId: string,
      body: EngineCreateAttemptRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling createAttempt.'
        )
      }
      // verify required parameter 'memberId' is not null or undefined
      if (memberId === null || memberId === undefined) {
        throw new RequiredError(
          'memberId',
          'Required parameter memberId was null or undefined when calling createAttempt.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createAttempt.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{member_id}/attempts`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'member_id'}}`, encodeURIComponent(String(memberId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMember: async (
      queueId: string,
      body: EngineCreateMemberRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling createMember.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createMember.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberBulkRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMemberBulk: async (
      queueId: string,
      body: EngineCreateMemberBulkRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling createMemberBulk.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createMemberBulk.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/bulk`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary DeleteMember
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMember: async (
      queueId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling deleteMember.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteMember.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary DeleteMembers
     * @param {string} queueId
     * @param {EngineDeleteMembersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMembers: async (
      queueId: string,
      body: EngineDeleteMembersRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling deleteMembers.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling deleteMembers.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Patch Member
     * @param {string} queueId
     * @param {string} id
     * @param {EnginePatchMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchMember: async (
      queueId: string,
      id: string,
      body: EnginePatchMemberRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling patchMember.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling patchMember.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling patchMember.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readMember: async (
      queueId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling readMember.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readMember.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ResetMembers
     * @param {string} queueId
     * @param {EngineResetMembersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetMembers: async (
      queueId: string,
      body: EngineResetMembersRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling resetMembers.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling resetMembers.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/reset`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SearchAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [result]
     * @param {string} [leavingAtFrom]
     * @param {string} [leavingAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAttempts: async (
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: Array<string>,
      leavingAtFrom?: string,
      leavingAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      durationFrom?: string,
      durationTo?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/queues/attempts/active`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (joinedAtFrom !== undefined) {
        localVarQueryParameter['joined_at.from'] = joinedAtFrom
      }

      if (joinedAtTo !== undefined) {
        localVarQueryParameter['joined_at.to'] = joinedAtTo
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (bucketId) {
        localVarQueryParameter['bucket_id'] = bucketId
      }

      if (memberId) {
        localVarQueryParameter['member_id'] = memberId
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (result) {
        localVarQueryParameter['result'] = result
      }

      if (leavingAtFrom !== undefined) {
        localVarQueryParameter['leaving_at.from'] = leavingAtFrom
      }

      if (leavingAtTo !== undefined) {
        localVarQueryParameter['leaving_at.to'] = leavingAtTo
      }

      if (offeringAtFrom !== undefined) {
        localVarQueryParameter['offering_at.from'] = offeringAtFrom
      }

      if (offeringAtTo !== undefined) {
        localVarQueryParameter['offering_at.to'] = offeringAtTo
      }

      if (durationFrom !== undefined) {
        localVarQueryParameter['duration.from'] = durationFrom
      }

      if (durationTo !== undefined) {
        localVarQueryParameter['duration.to'] = durationTo
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [result]
     * @param {string} [leavingAtFrom]
     * @param {string} [leavingAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAttemptsHistory: async (
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: Array<string>,
      leavingAtFrom?: string,
      leavingAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      durationFrom?: string,
      durationTo?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/queues/attempts/history`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (joinedAtFrom !== undefined) {
        localVarQueryParameter['joined_at.from'] = joinedAtFrom
      }

      if (joinedAtTo !== undefined) {
        localVarQueryParameter['joined_at.to'] = joinedAtTo
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (bucketId) {
        localVarQueryParameter['bucket_id'] = bucketId
      }

      if (memberId) {
        localVarQueryParameter['member_id'] = memberId
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (result) {
        localVarQueryParameter['result'] = result
      }

      if (leavingAtFrom !== undefined) {
        localVarQueryParameter['leaving_at.from'] = leavingAtFrom
      }

      if (leavingAtTo !== undefined) {
        localVarQueryParameter['leaving_at.to'] = leavingAtTo
      }

      if (offeringAtFrom !== undefined) {
        localVarQueryParameter['offering_at.from'] = offeringAtFrom
      }

      if (offeringAtTo !== undefined) {
        localVarQueryParameter['offering_at.to'] = offeringAtTo
      }

      if (durationFrom !== undefined) {
        localVarQueryParameter['duration.from'] = durationFrom
      }

      if (durationTo !== undefined) {
        localVarQueryParameter['duration.to'] = durationTo
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {string} queueId
     * @param {string} memberId
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMemberAttempts: async (
      queueId: string,
      memberId: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling searchMemberAttempts.'
        )
      }
      // verify required parameter 'memberId' is not null or undefined
      if (memberId === null || memberId === undefined) {
        throw new RequiredError(
          'memberId',
          'Required parameter memberId was null or undefined when calling searchMemberAttempts.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{member_id}/attempts`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'member_id'}}`, encodeURIComponent(String(memberId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of Member
     * @param {number} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [id]
     * @param {Array<number>} [bucketId]
     * @param {string} [destination]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {Array<string>} [stopCause]
     * @param {string} [priorityFrom]
     * @param {string} [priorityTo]
     * @param {string} [name]
     * @param {string} [attemptsFrom]
     * @param {string} [attemptsTo]
     * @param {Array<number>} [agentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMemberInQueue: async (
      queueId: number,
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      id?: Array<string>,
      bucketId?: Array<number>,
      destination?: string,
      createdAtFrom?: string,
      createdAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      stopCause?: Array<string>,
      priorityFrom?: string,
      priorityTo?: string,
      name?: string,
      attemptsFrom?: string,
      attemptsTo?: string,
      agentId?: Array<number>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling searchMemberInQueue.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (bucketId) {
        localVarQueryParameter['bucket_id'] = bucketId
      }

      if (destination !== undefined) {
        localVarQueryParameter['destination'] = destination
      }

      if (createdAtFrom !== undefined) {
        localVarQueryParameter['created_at.from'] = createdAtFrom
      }

      if (createdAtTo !== undefined) {
        localVarQueryParameter['created_at.to'] = createdAtTo
      }

      if (offeringAtFrom !== undefined) {
        localVarQueryParameter['offering_at.from'] = offeringAtFrom
      }

      if (offeringAtTo !== undefined) {
        localVarQueryParameter['offering_at.to'] = offeringAtTo
      }

      if (stopCause) {
        localVarQueryParameter['stop_cause'] = stopCause
      }

      if (priorityFrom !== undefined) {
        localVarQueryParameter['priority.from'] = priorityFrom
      }

      if (priorityTo !== undefined) {
        localVarQueryParameter['priority.to'] = priorityTo
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (attemptsFrom !== undefined) {
        localVarQueryParameter['attempts.from'] = attemptsFrom
      }

      if (attemptsTo !== undefined) {
        localVarQueryParameter['attempts.to'] = attemptsTo
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Search of Member
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [id]
     * @param {Array<number>} [queueId]
     * @param {Array<number>} [bucketId]
     * @param {string} [destination]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {Array<string>} [stopCause]
     * @param {string} [priorityFrom]
     * @param {string} [priorityTo]
     * @param {string} [name]
     * @param {string} [attemptsFrom]
     * @param {string} [attemptsTo]
     * @param {Array<number>} [agentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMembers: async (
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      id?: Array<string>,
      queueId?: Array<number>,
      bucketId?: Array<number>,
      destination?: string,
      createdAtFrom?: string,
      createdAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      stopCause?: Array<string>,
      priorityFrom?: string,
      priorityTo?: string,
      name?: string,
      attemptsFrom?: string,
      attemptsTo?: string,
      agentId?: Array<number>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/members`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (bucketId) {
        localVarQueryParameter['bucket_id'] = bucketId
      }

      if (destination !== undefined) {
        localVarQueryParameter['destination'] = destination
      }

      if (createdAtFrom !== undefined) {
        localVarQueryParameter['created_at.from'] = createdAtFrom
      }

      if (createdAtTo !== undefined) {
        localVarQueryParameter['created_at.to'] = createdAtTo
      }

      if (offeringAtFrom !== undefined) {
        localVarQueryParameter['offering_at.from'] = offeringAtFrom
      }

      if (offeringAtTo !== undefined) {
        localVarQueryParameter['offering_at.to'] = offeringAtTo
      }

      if (stopCause) {
        localVarQueryParameter['stop_cause'] = stopCause
      }

      if (priorityFrom !== undefined) {
        localVarQueryParameter['priority.from'] = priorityFrom
      }

      if (priorityTo !== undefined) {
        localVarQueryParameter['priority.to'] = priorityTo
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (attemptsFrom !== undefined) {
        localVarQueryParameter['attempts.from'] = attemptsFrom
      }

      if (attemptsTo !== undefined) {
        localVarQueryParameter['attempts.to'] = attemptsTo
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary UpdateMember
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMember: async (
      queueId: string,
      id: string,
      body: EngineUpdateMemberRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling updateMember.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateMember.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateMember.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * MemberServiceApi - functional programming interface
 * @export
 */
export const MemberServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} attemptId
     * @param {EngineAttemptCallbackRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async attemptCallback(
      attemptId: string,
      body: EngineAttemptCallbackRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAttemptResultResponse>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).attemptCallback(attemptId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {number} queueId
     * @param {string} memberId
     * @param {string} attemptId
     * @param {EngineAttemptResultRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async attemptResult(
      queueId: number,
      memberId: string,
      attemptId: string,
      body: EngineAttemptResultRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAttemptResultResponse>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).attemptResult(queueId, memberId, attemptId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} attemptId
     * @param {EngineAttemptRenewalResultRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async attemptsRenewalResult(
      attemptId: string,
      body: EngineAttemptRenewalResultRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).attemptsRenewalResult(attemptId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Offline queue
     * @param {string} queueId
     * @param {string} memberId
     * @param {EngineCreateAttemptRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAttempt(
      queueId: string,
      memberId: string,
      body: EngineCreateAttemptRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCreateAttemptResponse>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).createAttempt(queueId, memberId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMember(
      queueId: string,
      body: EngineCreateMemberRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberInQueue>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).createMember(queueId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberBulkRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMemberBulk(
      queueId: string,
      body: EngineCreateMemberBulkRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberBulkResponse>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).createMemberBulk(queueId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary DeleteMember
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMember(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberInQueue>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).deleteMember(queueId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary DeleteMembers
     * @param {string} queueId
     * @param {EngineDeleteMembersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMembers(
      queueId: string,
      body: EngineDeleteMembersRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListMember>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).deleteMembers(queueId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Patch Member
     * @param {string} queueId
     * @param {string} id
     * @param {EnginePatchMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchMember(
      queueId: string,
      id: string,
      body: EnginePatchMemberRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberInQueue>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).patchMember(queueId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readMember(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberInQueue>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).readMember(queueId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary ResetMembers
     * @param {string} queueId
     * @param {EngineResetMembersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetMembers(
      queueId: string,
      body: EngineResetMembersRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResetMembersResponse>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).resetMembers(queueId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SearchAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [result]
     * @param {string} [leavingAtFrom]
     * @param {string} [leavingAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAttempts(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: Array<string>,
      leavingAtFrom?: string,
      leavingAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      durationFrom?: string,
      durationTo?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAttempt>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).searchAttempts(
        page,
        size,
        q,
        sort,
        fields,
        joinedAtFrom,
        joinedAtTo,
        id,
        queueId,
        bucketId,
        memberId,
        agentId,
        result,
        leavingAtFrom,
        leavingAtTo,
        offeringAtFrom,
        offeringAtTo,
        durationFrom,
        durationTo,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [result]
     * @param {string} [leavingAtFrom]
     * @param {string} [leavingAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAttemptsHistory(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: Array<string>,
      leavingAtFrom?: string,
      leavingAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      durationFrom?: string,
      durationTo?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListHistoryAttempt>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).searchAttemptsHistory(
        page,
        size,
        q,
        sort,
        fields,
        joinedAtFrom,
        joinedAtTo,
        id,
        queueId,
        bucketId,
        memberId,
        agentId,
        result,
        leavingAtFrom,
        leavingAtTo,
        offeringAtFrom,
        offeringAtTo,
        durationFrom,
        durationTo,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {string} queueId
     * @param {string} memberId
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchMemberAttempts(
      queueId: string,
      memberId: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListMemberAttempt>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).searchMemberAttempts(queueId, memberId, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of Member
     * @param {number} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [id]
     * @param {Array<number>} [bucketId]
     * @param {string} [destination]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {Array<string>} [stopCause]
     * @param {string} [priorityFrom]
     * @param {string} [priorityTo]
     * @param {string} [name]
     * @param {string} [attemptsFrom]
     * @param {string} [attemptsTo]
     * @param {Array<number>} [agentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchMemberInQueue(
      queueId: number,
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      id?: Array<string>,
      bucketId?: Array<number>,
      destination?: string,
      createdAtFrom?: string,
      createdAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      stopCause?: Array<string>,
      priorityFrom?: string,
      priorityTo?: string,
      name?: string,
      attemptsFrom?: string,
      attemptsTo?: string,
      agentId?: Array<number>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListMember>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).searchMemberInQueue(
        queueId,
        page,
        size,
        q,
        sort,
        fields,
        id,
        bucketId,
        destination,
        createdAtFrom,
        createdAtTo,
        offeringAtFrom,
        offeringAtTo,
        stopCause,
        priorityFrom,
        priorityTo,
        name,
        attemptsFrom,
        attemptsTo,
        agentId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Search of Member
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [id]
     * @param {Array<number>} [queueId]
     * @param {Array<number>} [bucketId]
     * @param {string} [destination]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {Array<string>} [stopCause]
     * @param {string} [priorityFrom]
     * @param {string} [priorityTo]
     * @param {string} [name]
     * @param {string} [attemptsFrom]
     * @param {string} [attemptsTo]
     * @param {Array<number>} [agentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchMembers(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      id?: Array<string>,
      queueId?: Array<number>,
      bucketId?: Array<number>,
      destination?: string,
      createdAtFrom?: string,
      createdAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      stopCause?: Array<string>,
      priorityFrom?: string,
      priorityTo?: string,
      name?: string,
      attemptsFrom?: string,
      attemptsTo?: string,
      agentId?: Array<number>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListMember>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).searchMembers(
        page,
        size,
        q,
        sort,
        fields,
        id,
        queueId,
        bucketId,
        destination,
        createdAtFrom,
        createdAtTo,
        offeringAtFrom,
        offeringAtTo,
        stopCause,
        priorityFrom,
        priorityTo,
        name,
        attemptsFrom,
        attemptsTo,
        agentId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary UpdateMember
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMember(
      queueId: string,
      id: string,
      body: EngineUpdateMemberRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberInQueue>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).updateMember(queueId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * MemberServiceApi - factory interface
 * @export
 */
export const MemberServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {string} attemptId
     * @param {EngineAttemptCallbackRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attemptCallback(
      attemptId: string,
      body: EngineAttemptCallbackRequest,
      options?: any
    ): AxiosPromise<EngineAttemptResultResponse> {
      return MemberServiceApiFp(configuration)
        .attemptCallback(attemptId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} queueId
     * @param {string} memberId
     * @param {string} attemptId
     * @param {EngineAttemptResultRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attemptResult(
      queueId: number,
      memberId: string,
      attemptId: string,
      body: EngineAttemptResultRequest,
      options?: any
    ): AxiosPromise<EngineAttemptResultResponse> {
      return MemberServiceApiFp(configuration)
        .attemptResult(queueId, memberId, attemptId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} attemptId
     * @param {EngineAttemptRenewalResultRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attemptsRenewalResult(
      attemptId: string,
      body: EngineAttemptRenewalResultRequest,
      options?: any
    ): AxiosPromise<object> {
      return MemberServiceApiFp(configuration)
        .attemptsRenewalResult(attemptId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Offline queue
     * @param {string} queueId
     * @param {string} memberId
     * @param {EngineCreateAttemptRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttempt(
      queueId: string,
      memberId: string,
      body: EngineCreateAttemptRequest,
      options?: any
    ): AxiosPromise<EngineCreateAttemptResponse> {
      return MemberServiceApiFp(configuration)
        .createAttempt(queueId, memberId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMember(
      queueId: string,
      body: EngineCreateMemberRequest,
      options?: any
    ): AxiosPromise<EngineMemberInQueue> {
      return MemberServiceApiFp(configuration)
        .createMember(queueId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberBulkRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMemberBulk(
      queueId: string,
      body: EngineCreateMemberBulkRequest,
      options?: any
    ): AxiosPromise<EngineMemberBulkResponse> {
      return MemberServiceApiFp(configuration)
        .createMemberBulk(queueId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary DeleteMember
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMember(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineMemberInQueue> {
      return MemberServiceApiFp(configuration)
        .deleteMember(queueId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary DeleteMembers
     * @param {string} queueId
     * @param {EngineDeleteMembersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMembers(
      queueId: string,
      body: EngineDeleteMembersRequest,
      options?: any
    ): AxiosPromise<EngineListMember> {
      return MemberServiceApiFp(configuration)
        .deleteMembers(queueId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Patch Member
     * @param {string} queueId
     * @param {string} id
     * @param {EnginePatchMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchMember(
      queueId: string,
      id: string,
      body: EnginePatchMemberRequest,
      options?: any
    ): AxiosPromise<EngineMemberInQueue> {
      return MemberServiceApiFp(configuration)
        .patchMember(queueId, id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readMember(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineMemberInQueue> {
      return MemberServiceApiFp(configuration)
        .readMember(queueId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ResetMembers
     * @param {string} queueId
     * @param {EngineResetMembersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetMembers(
      queueId: string,
      body: EngineResetMembersRequest,
      options?: any
    ): AxiosPromise<EngineResetMembersResponse> {
      return MemberServiceApiFp(configuration)
        .resetMembers(queueId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SearchAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [result]
     * @param {string} [leavingAtFrom]
     * @param {string} [leavingAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAttempts(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: Array<string>,
      leavingAtFrom?: string,
      leavingAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      durationFrom?: string,
      durationTo?: string,
      options?: any
    ): AxiosPromise<EngineListAttempt> {
      return MemberServiceApiFp(configuration)
        .searchAttempts(
          page,
          size,
          q,
          sort,
          fields,
          joinedAtFrom,
          joinedAtTo,
          id,
          queueId,
          bucketId,
          memberId,
          agentId,
          result,
          leavingAtFrom,
          leavingAtTo,
          offeringAtFrom,
          offeringAtTo,
          durationFrom,
          durationTo,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [result]
     * @param {string} [leavingAtFrom]
     * @param {string} [leavingAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAttemptsHistory(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: Array<string>,
      leavingAtFrom?: string,
      leavingAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      durationFrom?: string,
      durationTo?: string,
      options?: any
    ): AxiosPromise<EngineListHistoryAttempt> {
      return MemberServiceApiFp(configuration)
        .searchAttemptsHistory(
          page,
          size,
          q,
          sort,
          fields,
          joinedAtFrom,
          joinedAtTo,
          id,
          queueId,
          bucketId,
          memberId,
          agentId,
          result,
          leavingAtFrom,
          leavingAtTo,
          offeringAtFrom,
          offeringAtTo,
          durationFrom,
          durationTo,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {string} queueId
     * @param {string} memberId
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMemberAttempts(
      queueId: string,
      memberId: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListMemberAttempt> {
      return MemberServiceApiFp(configuration)
        .searchMemberAttempts(queueId, memberId, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of Member
     * @param {number} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [id]
     * @param {Array<number>} [bucketId]
     * @param {string} [destination]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {Array<string>} [stopCause]
     * @param {string} [priorityFrom]
     * @param {string} [priorityTo]
     * @param {string} [name]
     * @param {string} [attemptsFrom]
     * @param {string} [attemptsTo]
     * @param {Array<number>} [agentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMemberInQueue(
      queueId: number,
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      id?: Array<string>,
      bucketId?: Array<number>,
      destination?: string,
      createdAtFrom?: string,
      createdAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      stopCause?: Array<string>,
      priorityFrom?: string,
      priorityTo?: string,
      name?: string,
      attemptsFrom?: string,
      attemptsTo?: string,
      agentId?: Array<number>,
      options?: any
    ): AxiosPromise<EngineListMember> {
      return MemberServiceApiFp(configuration)
        .searchMemberInQueue(
          queueId,
          page,
          size,
          q,
          sort,
          fields,
          id,
          bucketId,
          destination,
          createdAtFrom,
          createdAtTo,
          offeringAtFrom,
          offeringAtTo,
          stopCause,
          priorityFrom,
          priorityTo,
          name,
          attemptsFrom,
          attemptsTo,
          agentId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Search of Member
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [id]
     * @param {Array<number>} [queueId]
     * @param {Array<number>} [bucketId]
     * @param {string} [destination]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {string} [offeringAtFrom]
     * @param {string} [offeringAtTo]
     * @param {Array<string>} [stopCause]
     * @param {string} [priorityFrom]
     * @param {string} [priorityTo]
     * @param {string} [name]
     * @param {string} [attemptsFrom]
     * @param {string} [attemptsTo]
     * @param {Array<number>} [agentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMembers(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      id?: Array<string>,
      queueId?: Array<number>,
      bucketId?: Array<number>,
      destination?: string,
      createdAtFrom?: string,
      createdAtTo?: string,
      offeringAtFrom?: string,
      offeringAtTo?: string,
      stopCause?: Array<string>,
      priorityFrom?: string,
      priorityTo?: string,
      name?: string,
      attemptsFrom?: string,
      attemptsTo?: string,
      agentId?: Array<number>,
      options?: any
    ): AxiosPromise<EngineListMember> {
      return MemberServiceApiFp(configuration)
        .searchMembers(
          page,
          size,
          q,
          sort,
          fields,
          id,
          queueId,
          bucketId,
          destination,
          createdAtFrom,
          createdAtTo,
          offeringAtFrom,
          offeringAtTo,
          stopCause,
          priorityFrom,
          priorityTo,
          name,
          attemptsFrom,
          attemptsTo,
          agentId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary UpdateMember
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMember(
      queueId: string,
      id: string,
      body: EngineUpdateMemberRequest,
      options?: any
    ): AxiosPromise<EngineMemberInQueue> {
      return MemberServiceApiFp(configuration)
        .updateMember(queueId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * MemberServiceApi - object-oriented interface
 * @export
 * @class MemberServiceApi
 * @extends {BaseAPI}
 */
export class MemberServiceApi extends BaseAPI {
  /**
   *
   * @param {string} attemptId
   * @param {EngineAttemptCallbackRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public attemptCallback(
    attemptId: string,
    body: EngineAttemptCallbackRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .attemptCallback(attemptId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} queueId
   * @param {string} memberId
   * @param {string} attemptId
   * @param {EngineAttemptResultRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public attemptResult(
    queueId: number,
    memberId: string,
    attemptId: string,
    body: EngineAttemptResultRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .attemptResult(queueId, memberId, attemptId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} attemptId
   * @param {EngineAttemptRenewalResultRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public attemptsRenewalResult(
    attemptId: string,
    body: EngineAttemptRenewalResultRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .attemptsRenewalResult(attemptId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Offline queue
   * @param {string} queueId
   * @param {string} memberId
   * @param {EngineCreateAttemptRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public createAttempt(
    queueId: string,
    memberId: string,
    body: EngineCreateAttemptRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .createAttempt(queueId, memberId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Member
   * @param {string} queueId
   * @param {EngineCreateMemberRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public createMember(
    queueId: string,
    body: EngineCreateMemberRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .createMember(queueId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Member
   * @param {string} queueId
   * @param {EngineCreateMemberBulkRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public createMemberBulk(
    queueId: string,
    body: EngineCreateMemberBulkRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .createMemberBulk(queueId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary DeleteMember
   * @param {string} queueId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public deleteMember(
    queueId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .deleteMember(queueId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary DeleteMembers
   * @param {string} queueId
   * @param {EngineDeleteMembersRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public deleteMembers(
    queueId: string,
    body: EngineDeleteMembersRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .deleteMembers(queueId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Patch Member
   * @param {string} queueId
   * @param {string} id
   * @param {EnginePatchMemberRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public patchMember(
    queueId: string,
    id: string,
    body: EnginePatchMemberRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .patchMember(queueId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ReadQueueRouting
   * @param {string} queueId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public readMember(
    queueId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .readMember(queueId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ResetMembers
   * @param {string} queueId
   * @param {EngineResetMembersRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public resetMembers(
    queueId: string,
    body: EngineResetMembersRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .resetMembers(queueId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SearchAttempts
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [sort]
   * @param {Array<string>} [fields]
   * @param {string} [joinedAtFrom]
   * @param {string} [joinedAtTo]
   * @param {Array<string>} [id]
   * @param {Array<string>} [queueId]
   * @param {Array<string>} [bucketId]
   * @param {Array<string>} [memberId]
   * @param {Array<string>} [agentId]
   * @param {Array<string>} [result]
   * @param {string} [leavingAtFrom]
   * @param {string} [leavingAtTo]
   * @param {string} [offeringAtFrom]
   * @param {string} [offeringAtTo]
   * @param {string} [durationFrom]
   * @param {string} [durationTo]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public searchAttempts(
    page?: number,
    size?: number,
    q?: string,
    sort?: string,
    fields?: Array<string>,
    joinedAtFrom?: string,
    joinedAtTo?: string,
    id?: Array<string>,
    queueId?: Array<string>,
    bucketId?: Array<string>,
    memberId?: Array<string>,
    agentId?: Array<string>,
    result?: Array<string>,
    leavingAtFrom?: string,
    leavingAtTo?: string,
    offeringAtFrom?: string,
    offeringAtTo?: string,
    durationFrom?: string,
    durationTo?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .searchAttempts(
        page,
        size,
        q,
        sort,
        fields,
        joinedAtFrom,
        joinedAtTo,
        id,
        queueId,
        bucketId,
        memberId,
        agentId,
        result,
        leavingAtFrom,
        leavingAtTo,
        offeringAtFrom,
        offeringAtTo,
        durationFrom,
        durationTo,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SearchMemberAttempts
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [sort]
   * @param {Array<string>} [fields]
   * @param {string} [joinedAtFrom]
   * @param {string} [joinedAtTo]
   * @param {Array<string>} [id]
   * @param {Array<string>} [queueId]
   * @param {Array<string>} [bucketId]
   * @param {Array<string>} [memberId]
   * @param {Array<string>} [agentId]
   * @param {Array<string>} [result]
   * @param {string} [leavingAtFrom]
   * @param {string} [leavingAtTo]
   * @param {string} [offeringAtFrom]
   * @param {string} [offeringAtTo]
   * @param {string} [durationFrom]
   * @param {string} [durationTo]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public searchAttemptsHistory(
    page?: number,
    size?: number,
    q?: string,
    sort?: string,
    fields?: Array<string>,
    joinedAtFrom?: string,
    joinedAtTo?: string,
    id?: Array<string>,
    queueId?: Array<string>,
    bucketId?: Array<string>,
    memberId?: Array<string>,
    agentId?: Array<string>,
    result?: Array<string>,
    leavingAtFrom?: string,
    leavingAtTo?: string,
    offeringAtFrom?: string,
    offeringAtTo?: string,
    durationFrom?: string,
    durationTo?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .searchAttemptsHistory(
        page,
        size,
        q,
        sort,
        fields,
        joinedAtFrom,
        joinedAtTo,
        id,
        queueId,
        bucketId,
        memberId,
        agentId,
        result,
        leavingAtFrom,
        leavingAtTo,
        offeringAtFrom,
        offeringAtTo,
        durationFrom,
        durationTo,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SearchMemberAttempts
   * @param {string} queueId
   * @param {string} memberId
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public searchMemberAttempts(
    queueId: string,
    memberId: string,
    domainId?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .searchMemberAttempts(queueId, memberId, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of Member
   * @param {number} queueId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [sort]
   * @param {Array<string>} [fields]
   * @param {Array<string>} [id]
   * @param {Array<number>} [bucketId]
   * @param {string} [destination]
   * @param {string} [createdAtFrom]
   * @param {string} [createdAtTo]
   * @param {string} [offeringAtFrom]
   * @param {string} [offeringAtTo]
   * @param {Array<string>} [stopCause]
   * @param {string} [priorityFrom]
   * @param {string} [priorityTo]
   * @param {string} [name]
   * @param {string} [attemptsFrom]
   * @param {string} [attemptsTo]
   * @param {Array<number>} [agentId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public searchMemberInQueue(
    queueId: number,
    page?: number,
    size?: number,
    q?: string,
    sort?: string,
    fields?: Array<string>,
    id?: Array<string>,
    bucketId?: Array<number>,
    destination?: string,
    createdAtFrom?: string,
    createdAtTo?: string,
    offeringAtFrom?: string,
    offeringAtTo?: string,
    stopCause?: Array<string>,
    priorityFrom?: string,
    priorityTo?: string,
    name?: string,
    attemptsFrom?: string,
    attemptsTo?: string,
    agentId?: Array<number>,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .searchMemberInQueue(
        queueId,
        page,
        size,
        q,
        sort,
        fields,
        id,
        bucketId,
        destination,
        createdAtFrom,
        createdAtTo,
        offeringAtFrom,
        offeringAtTo,
        stopCause,
        priorityFrom,
        priorityTo,
        name,
        attemptsFrom,
        attemptsTo,
        agentId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Search of Member
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [sort]
   * @param {Array<string>} [fields]
   * @param {Array<string>} [id]
   * @param {Array<number>} [queueId]
   * @param {Array<number>} [bucketId]
   * @param {string} [destination]
   * @param {string} [createdAtFrom]
   * @param {string} [createdAtTo]
   * @param {string} [offeringAtFrom]
   * @param {string} [offeringAtTo]
   * @param {Array<string>} [stopCause]
   * @param {string} [priorityFrom]
   * @param {string} [priorityTo]
   * @param {string} [name]
   * @param {string} [attemptsFrom]
   * @param {string} [attemptsTo]
   * @param {Array<number>} [agentId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public searchMembers(
    page?: number,
    size?: number,
    q?: string,
    sort?: string,
    fields?: Array<string>,
    id?: Array<string>,
    queueId?: Array<number>,
    bucketId?: Array<number>,
    destination?: string,
    createdAtFrom?: string,
    createdAtTo?: string,
    offeringAtFrom?: string,
    offeringAtTo?: string,
    stopCause?: Array<string>,
    priorityFrom?: string,
    priorityTo?: string,
    name?: string,
    attemptsFrom?: string,
    attemptsTo?: string,
    agentId?: Array<number>,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .searchMembers(
        page,
        size,
        q,
        sort,
        fields,
        id,
        queueId,
        bucketId,
        destination,
        createdAtFrom,
        createdAtTo,
        offeringAtFrom,
        offeringAtTo,
        stopCause,
        priorityFrom,
        priorityTo,
        name,
        attemptsFrom,
        attemptsTo,
        agentId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary UpdateMember
   * @param {string} queueId
   * @param {string} id
   * @param {EngineUpdateMemberRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public updateMember(
    queueId: string,
    id: string,
    body: EngineUpdateMemberRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .updateMember(queueId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
