// tslint:disable
/**
 * Webitel engine API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 22.05.0
 * Contact: support@webitel.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
import { Configuration } from '../configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base'
// @ts-ignore
import { EngineActiveCall } from '../api'
// @ts-ignore
import { EngineAggregateHistoryCallRequest } from '../api'
// @ts-ignore
import { EngineBlindTransferCallRequest } from '../api'
// @ts-ignore
import { EngineCallAnnotation } from '../api'
// @ts-ignore
import { EngineCreateCallAnnotationRequest } from '../api'
// @ts-ignore
import { EngineCreateCallRequest } from '../api'
// @ts-ignore
import { EngineCreateCallResponse } from '../api'
// @ts-ignore
import { EngineDtmfCallRequest } from '../api'
// @ts-ignore
import { EngineEavesdropCallRequest } from '../api'
// @ts-ignore
import { EngineHangupCallRequest } from '../api'
// @ts-ignore
import { EngineHoldCallResponse } from '../api'
// @ts-ignore
import { EngineListAggregate } from '../api'
// @ts-ignore
import { EngineListCall } from '../api'
// @ts-ignore
import { EngineListHistoryCall } from '../api'
// @ts-ignore
import { EngineUpdateCallAnnotationRequest } from '../api'
// @ts-ignore
import { EngineUserCallRequest } from '../api'
// @ts-ignore
import { RuntimeError } from '../api'
/**
 * CallServiceApi - axios parameter creator
 * @export
 */
export const CallServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {EngineAggregateHistoryCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceAggregateHistoryCall: async (
      body: EngineAggregateHistoryCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling callServiceAggregateHistoryCall.'
        )
      }
      const localVarPath = `/calls/history/aggregate`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineBlindTransferCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceBlindTransferCall: async (
      id: string,
      body: EngineBlindTransferCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling callServiceBlindTransferCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling callServiceBlindTransferCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/transfer`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceConfirmPush: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling callServiceConfirmPush.'
        )
      }
      const localVarPath = `/calls/active/{id}/confirm_push`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {EngineCreateCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceCreateCall: async (
      body: EngineCreateCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling callServiceCreateCall.'
        )
      }
      const localVarPath = `/calls`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} callId
     * @param {EngineCreateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceCreateCallAnnotation: async (
      callId: string,
      body: EngineCreateCallAnnotationRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'callId' is not null or undefined
      if (callId === null || callId === undefined) {
        throw new RequiredError(
          'callId',
          'Required parameter callId was null or undefined when calling callServiceCreateCallAnnotation.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling callServiceCreateCallAnnotation.'
        )
      }
      const localVarPath = `/calls/history/{call_id}/annotation`.replace(
        `{${'call_id'}}`,
        encodeURIComponent(String(callId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceDeleteCallAnnotation: async (
      callId: string,
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'callId' is not null or undefined
      if (callId === null || callId === undefined) {
        throw new RequiredError(
          'callId',
          'Required parameter callId was null or undefined when calling callServiceDeleteCallAnnotation.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling callServiceDeleteCallAnnotation.'
        )
      }
      const localVarPath = `/calls/history/{call_id}/annotation/{id}`
        .replace(`{${'call_id'}}`, encodeURIComponent(String(callId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineDtmfCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceDtmfCall: async (
      id: string,
      body: EngineDtmfCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling callServiceDtmfCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling callServiceDtmfCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/dtmf`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineEavesdropCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceEavesdropCall: async (
      id: string,
      body: EngineEavesdropCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling callServiceEavesdropCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling callServiceEavesdropCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/eavesdrop`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineHangupCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceHangupCall: async (
      id: string,
      body: EngineHangupCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling callServiceHangupCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling callServiceHangupCall.'
        )
      }
      const localVarPath = `/calls/active/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceHoldCall: async (
      id: string,
      body: EngineUserCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling callServiceHoldCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling callServiceHoldCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/hold`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceReadCall: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling callServiceReadCall.'
        )
      }
      const localVarPath = `/calls/active/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {boolean} [existsFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {Array<string>} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [supervisorId]
     * @param {Array<string>} [state]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceSearchActiveCall: async (
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      existsFile?: boolean,
      domainId?: string,
      number?: string,
      direction?: Array<string>,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      supervisorId?: Array<string>,
      state?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/calls/active`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (createdAtFrom !== undefined) {
        localVarQueryParameter['created_at.from'] = createdAtFrom
      }

      if (createdAtTo !== undefined) {
        localVarQueryParameter['created_at.to'] = createdAtTo
      }

      if (userId) {
        localVarQueryParameter['user_id'] = userId
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (teamId) {
        localVarQueryParameter['team_id'] = teamId
      }

      if (memberId) {
        localVarQueryParameter['member_id'] = memberId
      }

      if (gatewayId) {
        localVarQueryParameter['gateway_id'] = gatewayId
      }

      if (durationFrom !== undefined) {
        localVarQueryParameter['duration.from'] = durationFrom
      }

      if (durationTo !== undefined) {
        localVarQueryParameter['duration.to'] = durationTo
      }

      if (skipParent !== undefined) {
        localVarQueryParameter['skip_parent'] = skipParent
      }

      if (parentId !== undefined) {
        localVarQueryParameter['parent_id'] = parentId
      }

      if (cause) {
        localVarQueryParameter['cause'] = cause
      }

      if (existsFile !== undefined) {
        localVarQueryParameter['exists_file'] = existsFile
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (number !== undefined) {
        localVarQueryParameter['number'] = number
      }

      if (direction) {
        localVarQueryParameter['direction'] = direction
      }

      if (answeredAtFrom !== undefined) {
        localVarQueryParameter['answered_at.from'] = answeredAtFrom
      }

      if (answeredAtTo !== undefined) {
        localVarQueryParameter['answered_at.to'] = answeredAtTo
      }

      if (missed !== undefined) {
        localVarQueryParameter['missed'] = missed
      }

      if (storedAtFrom !== undefined) {
        localVarQueryParameter['stored_at.from'] = storedAtFrom
      }

      if (storedAtTo !== undefined) {
        localVarQueryParameter['stored_at.to'] = storedAtTo
      }

      if (supervisorId) {
        localVarQueryParameter['supervisor_id'] = supervisorId
      }

      if (state) {
        localVarQueryParameter['state'] = state
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of call
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {'undefined' | 'true' | 'false'} [hasFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {string} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [transferFrom]
     * @param {Array<string>} [transferTo]
     * @param {Array<string>} [dependencyId]
     * @param {Array<string>} [tags]
     * @param {Array<string>} [amdResult]
     * @param {string} [fts]
     * @param {Array<string>} [directions]
     * @param {'undefined' | 'true' | 'false'} [hasTranscript]
     * @param {string} [agentDescription]
     * @param {Array<string>} [ownerId]
     * @param {Array<string>} [granteeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceSearchHistoryCall: async (
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      hasFile?: 'undefined' | 'true' | 'false',
      domainId?: string,
      number?: string,
      direction?: string,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      id?: Array<string>,
      transferFrom?: Array<string>,
      transferTo?: Array<string>,
      dependencyId?: Array<string>,
      tags?: Array<string>,
      amdResult?: Array<string>,
      fts?: string,
      directions?: Array<string>,
      hasTranscript?: 'undefined' | 'true' | 'false',
      agentDescription?: string,
      ownerId?: Array<string>,
      granteeId?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/calls/history`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (createdAtFrom !== undefined) {
        localVarQueryParameter['created_at.from'] = createdAtFrom
      }

      if (createdAtTo !== undefined) {
        localVarQueryParameter['created_at.to'] = createdAtTo
      }

      if (userId) {
        localVarQueryParameter['user_id'] = userId
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (teamId) {
        localVarQueryParameter['team_id'] = teamId
      }

      if (memberId) {
        localVarQueryParameter['member_id'] = memberId
      }

      if (gatewayId) {
        localVarQueryParameter['gateway_id'] = gatewayId
      }

      if (durationFrom !== undefined) {
        localVarQueryParameter['duration.from'] = durationFrom
      }

      if (durationTo !== undefined) {
        localVarQueryParameter['duration.to'] = durationTo
      }

      if (skipParent !== undefined) {
        localVarQueryParameter['skip_parent'] = skipParent
      }

      if (parentId !== undefined) {
        localVarQueryParameter['parent_id'] = parentId
      }

      if (cause) {
        localVarQueryParameter['cause'] = cause
      }

      if (hasFile !== undefined) {
        localVarQueryParameter['has_file'] = hasFile
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (number !== undefined) {
        localVarQueryParameter['number'] = number
      }

      if (direction !== undefined) {
        localVarQueryParameter['direction'] = direction
      }

      if (answeredAtFrom !== undefined) {
        localVarQueryParameter['answered_at.from'] = answeredAtFrom
      }

      if (answeredAtTo !== undefined) {
        localVarQueryParameter['answered_at.to'] = answeredAtTo
      }

      if (missed !== undefined) {
        localVarQueryParameter['missed'] = missed
      }

      if (storedAtFrom !== undefined) {
        localVarQueryParameter['stored_at.from'] = storedAtFrom
      }

      if (storedAtTo !== undefined) {
        localVarQueryParameter['stored_at.to'] = storedAtTo
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (transferFrom) {
        localVarQueryParameter['transfer_from'] = transferFrom
      }

      if (transferTo) {
        localVarQueryParameter['transfer_to'] = transferTo
      }

      if (dependencyId) {
        localVarQueryParameter['dependency_id'] = dependencyId
      }

      if (tags) {
        localVarQueryParameter['tags'] = tags
      }

      if (amdResult) {
        localVarQueryParameter['amd_result'] = amdResult
      }

      if (fts !== undefined) {
        localVarQueryParameter['fts'] = fts
      }

      if (directions) {
        localVarQueryParameter['directions'] = directions
      }

      if (hasTranscript !== undefined) {
        localVarQueryParameter['has_transcript'] = hasTranscript
      }

      if (agentDescription !== undefined) {
        localVarQueryParameter['agent_description'] = agentDescription
      }

      if (ownerId) {
        localVarQueryParameter['owner_id'] = ownerId
      }

      if (granteeId) {
        localVarQueryParameter['grantee_id'] = granteeId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceUnHoldCall: async (
      id: string,
      body: EngineUserCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling callServiceUnHoldCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling callServiceUnHoldCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/unhold`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {EngineUpdateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceUpdateCallAnnotation: async (
      callId: string,
      id: string,
      body: EngineUpdateCallAnnotationRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'callId' is not null or undefined
      if (callId === null || callId === undefined) {
        throw new RequiredError(
          'callId',
          'Required parameter callId was null or undefined when calling callServiceUpdateCallAnnotation.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling callServiceUpdateCallAnnotation.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling callServiceUpdateCallAnnotation.'
        )
      }
      const localVarPath = `/calls/history/{call_id}/annotation/{id}`
        .replace(`{${'call_id'}}`, encodeURIComponent(String(callId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CallServiceApi - functional programming interface
 * @export
 */
export const CallServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {EngineAggregateHistoryCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceAggregateHistoryCall(
      body: EngineAggregateHistoryCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAggregate>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceAggregateHistoryCall(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineBlindTransferCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceBlindTransferCall(
      id: string,
      body: EngineBlindTransferCallRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceBlindTransferCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceConfirmPush(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceConfirmPush(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {EngineCreateCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceCreateCall(
      body: EngineCreateCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCreateCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceCreateCall(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} callId
     * @param {EngineCreateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceCreateCallAnnotation(
      callId: string,
      body: EngineCreateCallAnnotationRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCallAnnotation>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceCreateCallAnnotation(callId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceDeleteCallAnnotation(
      callId: string,
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCallAnnotation>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceDeleteCallAnnotation(callId, id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineDtmfCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceDtmfCall(
      id: string,
      body: EngineDtmfCallRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceDtmfCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineEavesdropCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceEavesdropCall(
      id: string,
      body: EngineEavesdropCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCreateCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceEavesdropCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineHangupCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceHangupCall(
      id: string,
      body: EngineHangupCallRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceHangupCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceHoldCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineHoldCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceHoldCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceReadCall(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineActiveCall>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceReadCall(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {boolean} [existsFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {Array<string>} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [supervisorId]
     * @param {Array<string>} [state]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceSearchActiveCall(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      existsFile?: boolean,
      domainId?: string,
      number?: string,
      direction?: Array<string>,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      supervisorId?: Array<string>,
      state?: Array<string>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineListCall>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceSearchActiveCall(
        page,
        size,
        q,
        sort,
        fields,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        existsFile,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        supervisorId,
        state,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of call
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {'undefined' | 'true' | 'false'} [hasFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {string} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [transferFrom]
     * @param {Array<string>} [transferTo]
     * @param {Array<string>} [dependencyId]
     * @param {Array<string>} [tags]
     * @param {Array<string>} [amdResult]
     * @param {string} [fts]
     * @param {Array<string>} [directions]
     * @param {'undefined' | 'true' | 'false'} [hasTranscript]
     * @param {string} [agentDescription]
     * @param {Array<string>} [ownerId]
     * @param {Array<string>} [granteeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceSearchHistoryCall(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      hasFile?: 'undefined' | 'true' | 'false',
      domainId?: string,
      number?: string,
      direction?: string,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      id?: Array<string>,
      transferFrom?: Array<string>,
      transferTo?: Array<string>,
      dependencyId?: Array<string>,
      tags?: Array<string>,
      amdResult?: Array<string>,
      fts?: string,
      directions?: Array<string>,
      hasTranscript?: 'undefined' | 'true' | 'false',
      agentDescription?: string,
      ownerId?: Array<string>,
      granteeId?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListHistoryCall>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceSearchHistoryCall(
        page,
        size,
        q,
        sort,
        fields,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        hasFile,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        id,
        transferFrom,
        transferTo,
        dependencyId,
        tags,
        amdResult,
        fts,
        directions,
        hasTranscript,
        agentDescription,
        ownerId,
        granteeId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceUnHoldCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineHoldCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceUnHoldCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {EngineUpdateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callServiceUpdateCallAnnotation(
      callId: string,
      id: string,
      body: EngineUpdateCallAnnotationRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCallAnnotation>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).callServiceUpdateCallAnnotation(callId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * CallServiceApi - factory interface
 * @export
 */
export const CallServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {EngineAggregateHistoryCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceAggregateHistoryCall(
      body: EngineAggregateHistoryCallRequest,
      options?: any
    ): AxiosPromise<EngineListAggregate> {
      return CallServiceApiFp(configuration)
        .callServiceAggregateHistoryCall(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineBlindTransferCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceBlindTransferCall(
      id: string,
      body: EngineBlindTransferCallRequest,
      options?: any
    ): AxiosPromise<object> {
      return CallServiceApiFp(configuration)
        .callServiceBlindTransferCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceConfirmPush(id: string, options?: any): AxiosPromise<object> {
      return CallServiceApiFp(configuration)
        .callServiceConfirmPush(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {EngineCreateCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceCreateCall(
      body: EngineCreateCallRequest,
      options?: any
    ): AxiosPromise<EngineCreateCallResponse> {
      return CallServiceApiFp(configuration)
        .callServiceCreateCall(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} callId
     * @param {EngineCreateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceCreateCallAnnotation(
      callId: string,
      body: EngineCreateCallAnnotationRequest,
      options?: any
    ): AxiosPromise<EngineCallAnnotation> {
      return CallServiceApiFp(configuration)
        .callServiceCreateCallAnnotation(callId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceDeleteCallAnnotation(
      callId: string,
      id: string,
      options?: any
    ): AxiosPromise<EngineCallAnnotation> {
      return CallServiceApiFp(configuration)
        .callServiceDeleteCallAnnotation(callId, id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineDtmfCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceDtmfCall(
      id: string,
      body: EngineDtmfCallRequest,
      options?: any
    ): AxiosPromise<object> {
      return CallServiceApiFp(configuration)
        .callServiceDtmfCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineEavesdropCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceEavesdropCall(
      id: string,
      body: EngineEavesdropCallRequest,
      options?: any
    ): AxiosPromise<EngineCreateCallResponse> {
      return CallServiceApiFp(configuration)
        .callServiceEavesdropCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineHangupCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceHangupCall(
      id: string,
      body: EngineHangupCallRequest,
      options?: any
    ): AxiosPromise<object> {
      return CallServiceApiFp(configuration)
        .callServiceHangupCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceHoldCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): AxiosPromise<EngineHoldCallResponse> {
      return CallServiceApiFp(configuration)
        .callServiceHoldCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceReadCall(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineActiveCall> {
      return CallServiceApiFp(configuration)
        .callServiceReadCall(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {boolean} [existsFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {Array<string>} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [supervisorId]
     * @param {Array<string>} [state]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceSearchActiveCall(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      existsFile?: boolean,
      domainId?: string,
      number?: string,
      direction?: Array<string>,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      supervisorId?: Array<string>,
      state?: Array<string>,
      options?: any
    ): AxiosPromise<EngineListCall> {
      return CallServiceApiFp(configuration)
        .callServiceSearchActiveCall(
          page,
          size,
          q,
          sort,
          fields,
          createdAtFrom,
          createdAtTo,
          userId,
          agentId,
          queueId,
          teamId,
          memberId,
          gatewayId,
          durationFrom,
          durationTo,
          skipParent,
          parentId,
          cause,
          existsFile,
          domainId,
          number,
          direction,
          answeredAtFrom,
          answeredAtTo,
          missed,
          storedAtFrom,
          storedAtTo,
          supervisorId,
          state,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of call
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {'undefined' | 'true' | 'false'} [hasFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {string} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [transferFrom]
     * @param {Array<string>} [transferTo]
     * @param {Array<string>} [dependencyId]
     * @param {Array<string>} [tags]
     * @param {Array<string>} [amdResult]
     * @param {string} [fts]
     * @param {Array<string>} [directions]
     * @param {'undefined' | 'true' | 'false'} [hasTranscript]
     * @param {string} [agentDescription]
     * @param {Array<string>} [ownerId]
     * @param {Array<string>} [granteeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceSearchHistoryCall(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      hasFile?: 'undefined' | 'true' | 'false',
      domainId?: string,
      number?: string,
      direction?: string,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      id?: Array<string>,
      transferFrom?: Array<string>,
      transferTo?: Array<string>,
      dependencyId?: Array<string>,
      tags?: Array<string>,
      amdResult?: Array<string>,
      fts?: string,
      directions?: Array<string>,
      hasTranscript?: 'undefined' | 'true' | 'false',
      agentDescription?: string,
      ownerId?: Array<string>,
      granteeId?: Array<string>,
      options?: any
    ): AxiosPromise<EngineListHistoryCall> {
      return CallServiceApiFp(configuration)
        .callServiceSearchHistoryCall(
          page,
          size,
          q,
          sort,
          fields,
          createdAtFrom,
          createdAtTo,
          userId,
          agentId,
          queueId,
          teamId,
          memberId,
          gatewayId,
          durationFrom,
          durationTo,
          skipParent,
          parentId,
          cause,
          hasFile,
          domainId,
          number,
          direction,
          answeredAtFrom,
          answeredAtTo,
          missed,
          storedAtFrom,
          storedAtTo,
          id,
          transferFrom,
          transferTo,
          dependencyId,
          tags,
          amdResult,
          fts,
          directions,
          hasTranscript,
          agentDescription,
          ownerId,
          granteeId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceUnHoldCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): AxiosPromise<EngineHoldCallResponse> {
      return CallServiceApiFp(configuration)
        .callServiceUnHoldCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {EngineUpdateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callServiceUpdateCallAnnotation(
      callId: string,
      id: string,
      body: EngineUpdateCallAnnotationRequest,
      options?: any
    ): AxiosPromise<EngineCallAnnotation> {
      return CallServiceApiFp(configuration)
        .callServiceUpdateCallAnnotation(callId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CallServiceApi - object-oriented interface
 * @export
 * @class CallServiceApi
 * @extends {BaseAPI}
 */
export class CallServiceApi extends BaseAPI {
  /**
   *
   * @param {EngineAggregateHistoryCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceAggregateHistoryCall(
    body: EngineAggregateHistoryCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceAggregateHistoryCall(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineBlindTransferCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceBlindTransferCall(
    id: string,
    body: EngineBlindTransferCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceBlindTransferCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Call item
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceConfirmPush(id: string, options?: any) {
    return CallServiceApiFp(this.configuration)
      .callServiceConfirmPush(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {EngineCreateCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceCreateCall(body: EngineCreateCallRequest, options?: any) {
    return CallServiceApiFp(this.configuration)
      .callServiceCreateCall(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} callId
   * @param {EngineCreateCallAnnotationRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceCreateCallAnnotation(
    callId: string,
    body: EngineCreateCallAnnotationRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceCreateCallAnnotation(callId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} callId
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceDeleteCallAnnotation(
    callId: string,
    id: string,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceDeleteCallAnnotation(callId, id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineDtmfCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceDtmfCall(
    id: string,
    body: EngineDtmfCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceDtmfCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineEavesdropCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceEavesdropCall(
    id: string,
    body: EngineEavesdropCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceEavesdropCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineHangupCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceHangupCall(
    id: string,
    body: EngineHangupCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceHangupCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineUserCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceHoldCall(
    id: string,
    body: EngineUserCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceHoldCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Call item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceReadCall(id: string, domainId?: string, options?: any) {
    return CallServiceApiFp(this.configuration)
      .callServiceReadCall(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [sort]
   * @param {Array<string>} [fields]
   * @param {string} [createdAtFrom]
   * @param {string} [createdAtTo]
   * @param {Array<string>} [userId]
   * @param {Array<string>} [agentId]
   * @param {Array<string>} [queueId]
   * @param {Array<string>} [teamId]
   * @param {Array<string>} [memberId]
   * @param {Array<string>} [gatewayId]
   * @param {string} [durationFrom]
   * @param {string} [durationTo]
   * @param {boolean} [skipParent]
   * @param {string} [parentId]
   * @param {Array<string>} [cause]
   * @param {boolean} [existsFile]
   * @param {string} [domainId]
   * @param {string} [number]
   * @param {Array<string>} [direction]
   * @param {string} [answeredAtFrom]
   * @param {string} [answeredAtTo]
   * @param {boolean} [missed]
   * @param {string} [storedAtFrom]
   * @param {string} [storedAtTo]
   * @param {Array<string>} [supervisorId]
   * @param {Array<string>} [state]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceSearchActiveCall(
    page?: number,
    size?: number,
    q?: string,
    sort?: string,
    fields?: Array<string>,
    createdAtFrom?: string,
    createdAtTo?: string,
    userId?: Array<string>,
    agentId?: Array<string>,
    queueId?: Array<string>,
    teamId?: Array<string>,
    memberId?: Array<string>,
    gatewayId?: Array<string>,
    durationFrom?: string,
    durationTo?: string,
    skipParent?: boolean,
    parentId?: string,
    cause?: Array<string>,
    existsFile?: boolean,
    domainId?: string,
    number?: string,
    direction?: Array<string>,
    answeredAtFrom?: string,
    answeredAtTo?: string,
    missed?: boolean,
    storedAtFrom?: string,
    storedAtTo?: string,
    supervisorId?: Array<string>,
    state?: Array<string>,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceSearchActiveCall(
        page,
        size,
        q,
        sort,
        fields,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        existsFile,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        supervisorId,
        state,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of call
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [sort]
   * @param {Array<string>} [fields]
   * @param {string} [createdAtFrom]
   * @param {string} [createdAtTo]
   * @param {Array<string>} [userId]
   * @param {Array<string>} [agentId]
   * @param {Array<string>} [queueId]
   * @param {Array<string>} [teamId]
   * @param {Array<string>} [memberId]
   * @param {Array<string>} [gatewayId]
   * @param {string} [durationFrom]
   * @param {string} [durationTo]
   * @param {boolean} [skipParent]
   * @param {string} [parentId]
   * @param {Array<string>} [cause]
   * @param {'undefined' | 'true' | 'false'} [hasFile]
   * @param {string} [domainId]
   * @param {string} [number]
   * @param {string} [direction]
   * @param {string} [answeredAtFrom]
   * @param {string} [answeredAtTo]
   * @param {boolean} [missed]
   * @param {string} [storedAtFrom]
   * @param {string} [storedAtTo]
   * @param {Array<string>} [id]
   * @param {Array<string>} [transferFrom]
   * @param {Array<string>} [transferTo]
   * @param {Array<string>} [dependencyId]
   * @param {Array<string>} [tags]
   * @param {Array<string>} [amdResult]
   * @param {string} [fts]
   * @param {Array<string>} [directions]
   * @param {'undefined' | 'true' | 'false'} [hasTranscript]
   * @param {string} [agentDescription]
   * @param {Array<string>} [ownerId]
   * @param {Array<string>} [granteeId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceSearchHistoryCall(
    page?: number,
    size?: number,
    q?: string,
    sort?: string,
    fields?: Array<string>,
    createdAtFrom?: string,
    createdAtTo?: string,
    userId?: Array<string>,
    agentId?: Array<string>,
    queueId?: Array<string>,
    teamId?: Array<string>,
    memberId?: Array<string>,
    gatewayId?: Array<string>,
    durationFrom?: string,
    durationTo?: string,
    skipParent?: boolean,
    parentId?: string,
    cause?: Array<string>,
    hasFile?: 'undefined' | 'true' | 'false',
    domainId?: string,
    number?: string,
    direction?: string,
    answeredAtFrom?: string,
    answeredAtTo?: string,
    missed?: boolean,
    storedAtFrom?: string,
    storedAtTo?: string,
    id?: Array<string>,
    transferFrom?: Array<string>,
    transferTo?: Array<string>,
    dependencyId?: Array<string>,
    tags?: Array<string>,
    amdResult?: Array<string>,
    fts?: string,
    directions?: Array<string>,
    hasTranscript?: 'undefined' | 'true' | 'false',
    agentDescription?: string,
    ownerId?: Array<string>,
    granteeId?: Array<string>,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceSearchHistoryCall(
        page,
        size,
        q,
        sort,
        fields,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        hasFile,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        id,
        transferFrom,
        transferTo,
        dependencyId,
        tags,
        amdResult,
        fts,
        directions,
        hasTranscript,
        agentDescription,
        ownerId,
        granteeId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineUserCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceUnHoldCall(
    id: string,
    body: EngineUserCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceUnHoldCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} callId
   * @param {string} id
   * @param {EngineUpdateCallAnnotationRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public callServiceUpdateCallAnnotation(
    callId: string,
    id: string,
    body: EngineUpdateCallAnnotationRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .callServiceUpdateCallAnnotation(callId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
