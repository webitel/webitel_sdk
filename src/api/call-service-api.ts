// tslint:disable
/**
 * Webitel engine API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 22.05.0
 * Contact: support@webitel.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
import { Configuration } from '../configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base'
// @ts-ignore
import { EngineActiveCall } from '../api'
// @ts-ignore
import { EngineAggregateHistoryCallRequest } from '../api'
// @ts-ignore
import { EngineBlindTransferCallRequest } from '../api'
// @ts-ignore
import { EngineCallAnnotation } from '../api'
// @ts-ignore
import { EngineCreateCallAnnotationRequest } from '../api'
// @ts-ignore
import { EngineCreateCallRequest } from '../api'
// @ts-ignore
import { EngineCreateCallResponse } from '../api'
// @ts-ignore
import { EngineDtmfCallRequest } from '../api'
// @ts-ignore
import { EngineEavesdropCallRequest } from '../api'
// @ts-ignore
import { EngineHangupCallRequest } from '../api'
// @ts-ignore
import { EngineHoldCallResponse } from '../api'
// @ts-ignore
import { EngineListAggregate } from '../api'
// @ts-ignore
import { EngineListCall } from '../api'
// @ts-ignore
import { EngineListHistoryCall } from '../api'
// @ts-ignore
import { EngineUpdateCallAnnotationRequest } from '../api'
// @ts-ignore
import { EngineUserCallRequest } from '../api'
/**
 * CallServiceApi - axios parameter creator
 * @export
 */
export const CallServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {EngineAggregateHistoryCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    aggregateHistoryCall: async (
      body: EngineAggregateHistoryCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling aggregateHistoryCall.'
        )
      }
      const localVarPath = `/calls/history/aggregate`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineBlindTransferCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blindTransferCall: async (
      id: string,
      body: EngineBlindTransferCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling blindTransferCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling blindTransferCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/transfer`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmPush: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling confirmPush.'
        )
      }
      const localVarPath = `/calls/active/{id}/confirm_push`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create e call
     * @param {EngineCreateCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCall: async (
      body: EngineCreateCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createCall.'
        )
      }
      const localVarPath = `/calls`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} callId
     * @param {EngineCreateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCallAnnotation: async (
      callId: string,
      body: EngineCreateCallAnnotationRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'callId' is not null or undefined
      if (callId === null || callId === undefined) {
        throw new RequiredError(
          'callId',
          'Required parameter callId was null or undefined when calling createCallAnnotation.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createCallAnnotation.'
        )
      }
      const localVarPath = `/calls/history/{call_id}/annotation`.replace(
        `{${'call_id'}}`,
        encodeURIComponent(String(callId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCallAnnotation: async (
      callId: string,
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'callId' is not null or undefined
      if (callId === null || callId === undefined) {
        throw new RequiredError(
          'callId',
          'Required parameter callId was null or undefined when calling deleteCallAnnotation.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteCallAnnotation.'
        )
      }
      const localVarPath = `/calls/history/{call_id}/annotation/{id}`
        .replace(`{${'call_id'}}`, encodeURIComponent(String(callId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineDtmfCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dtmfCall: async (
      id: string,
      body: EngineDtmfCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling dtmfCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling dtmfCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/dtmf`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineEavesdropCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eavesdropCall: async (
      id: string,
      body: EngineEavesdropCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling eavesdropCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling eavesdropCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/eavesdrop`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineHangupCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hangupCall: async (
      id: string,
      body: EngineHangupCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling hangupCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling hangupCall.'
        )
      }
      const localVarPath = `/calls/active/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    holdCall: async (
      id: string,
      body: EngineUserCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling holdCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling holdCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/hold`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readCall: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readCall.'
        )
      }
      const localVarPath = `/calls/active/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {boolean} [existsFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {Array<string>} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [supervisorId]
     * @param {Array<string>} [state]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchActiveCall: async (
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      existsFile?: boolean,
      domainId?: string,
      number?: string,
      direction?: Array<string>,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      supervisorId?: Array<string>,
      state?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/calls/active`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (createdAtFrom !== undefined) {
        localVarQueryParameter['created_at.from'] = createdAtFrom
      }

      if (createdAtTo !== undefined) {
        localVarQueryParameter['created_at.to'] = createdAtTo
      }

      if (userId) {
        localVarQueryParameter['user_id'] = userId
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (teamId) {
        localVarQueryParameter['team_id'] = teamId
      }

      if (memberId) {
        localVarQueryParameter['member_id'] = memberId
      }

      if (gatewayId) {
        localVarQueryParameter['gateway_id'] = gatewayId
      }

      if (durationFrom !== undefined) {
        localVarQueryParameter['duration.from'] = durationFrom
      }

      if (durationTo !== undefined) {
        localVarQueryParameter['duration.to'] = durationTo
      }

      if (skipParent !== undefined) {
        localVarQueryParameter['skip_parent'] = skipParent
      }

      if (parentId !== undefined) {
        localVarQueryParameter['parent_id'] = parentId
      }

      if (cause) {
        localVarQueryParameter['cause'] = cause
      }

      if (existsFile !== undefined) {
        localVarQueryParameter['exists_file'] = existsFile
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (number !== undefined) {
        localVarQueryParameter['number'] = number
      }

      if (direction) {
        localVarQueryParameter['direction'] = direction
      }

      if (answeredAtFrom !== undefined) {
        localVarQueryParameter['answered_at.from'] = answeredAtFrom
      }

      if (answeredAtTo !== undefined) {
        localVarQueryParameter['answered_at.to'] = answeredAtTo
      }

      if (missed !== undefined) {
        localVarQueryParameter['missed'] = missed
      }

      if (storedAtFrom !== undefined) {
        localVarQueryParameter['stored_at.from'] = storedAtFrom
      }

      if (storedAtTo !== undefined) {
        localVarQueryParameter['stored_at.to'] = storedAtTo
      }

      if (supervisorId) {
        localVarQueryParameter['supervisor_id'] = supervisorId
      }

      if (state) {
        localVarQueryParameter['state'] = state
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of call
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {boolean} [hasFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {string} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [transferFrom]
     * @param {Array<string>} [transferTo]
     * @param {Array<string>} [dependencyId]
     * @param {Array<string>} [tags]
     * @param {Array<string>} [amdResult]
     * @param {string} [fts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchHistoryCall: async (
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      hasFile?: boolean,
      domainId?: string,
      number?: string,
      direction?: string,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      id?: Array<string>,
      transferFrom?: Array<string>,
      transferTo?: Array<string>,
      dependencyId?: Array<string>,
      tags?: Array<string>,
      amdResult?: Array<string>,
      fts?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/calls/history`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (createdAtFrom !== undefined) {
        localVarQueryParameter['created_at.from'] = createdAtFrom
      }

      if (createdAtTo !== undefined) {
        localVarQueryParameter['created_at.to'] = createdAtTo
      }

      if (userId) {
        localVarQueryParameter['user_id'] = userId
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (teamId) {
        localVarQueryParameter['team_id'] = teamId
      }

      if (memberId) {
        localVarQueryParameter['member_id'] = memberId
      }

      if (gatewayId) {
        localVarQueryParameter['gateway_id'] = gatewayId
      }

      if (durationFrom !== undefined) {
        localVarQueryParameter['duration.from'] = durationFrom
      }

      if (durationTo !== undefined) {
        localVarQueryParameter['duration.to'] = durationTo
      }

      if (skipParent !== undefined) {
        localVarQueryParameter['skip_parent'] = skipParent
      }

      if (parentId !== undefined) {
        localVarQueryParameter['parent_id'] = parentId
      }

      if (cause) {
        localVarQueryParameter['cause'] = cause
      }

      if (hasFile !== undefined) {
        localVarQueryParameter['has_file'] = hasFile
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (number !== undefined) {
        localVarQueryParameter['number'] = number
      }

      if (direction !== undefined) {
        localVarQueryParameter['direction'] = direction
      }

      if (answeredAtFrom !== undefined) {
        localVarQueryParameter['answered_at.from'] = answeredAtFrom
      }

      if (answeredAtTo !== undefined) {
        localVarQueryParameter['answered_at.to'] = answeredAtTo
      }

      if (missed !== undefined) {
        localVarQueryParameter['missed'] = missed
      }

      if (storedAtFrom !== undefined) {
        localVarQueryParameter['stored_at.from'] = storedAtFrom
      }

      if (storedAtTo !== undefined) {
        localVarQueryParameter['stored_at.to'] = storedAtTo
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (transferFrom) {
        localVarQueryParameter['transfer_from'] = transferFrom
      }

      if (transferTo) {
        localVarQueryParameter['transfer_to'] = transferTo
      }

      if (dependencyId) {
        localVarQueryParameter['dependency_id'] = dependencyId
      }

      if (tags) {
        localVarQueryParameter['tags'] = tags
      }

      if (amdResult) {
        localVarQueryParameter['amd_result'] = amdResult
      }

      if (fts !== undefined) {
        localVarQueryParameter['fts'] = fts
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unHoldCall: async (
      id: string,
      body: EngineUserCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling unHoldCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling unHoldCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/unhold`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {EngineUpdateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCallAnnotation: async (
      callId: string,
      id: string,
      body: EngineUpdateCallAnnotationRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'callId' is not null or undefined
      if (callId === null || callId === undefined) {
        throw new RequiredError(
          'callId',
          'Required parameter callId was null or undefined when calling updateCallAnnotation.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateCallAnnotation.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateCallAnnotation.'
        )
      }
      const localVarPath = `/calls/history/{call_id}/annotation/{id}`
        .replace(`{${'call_id'}}`, encodeURIComponent(String(callId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CallServiceApi - functional programming interface
 * @export
 */
export const CallServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {EngineAggregateHistoryCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async aggregateHistoryCall(
      body: EngineAggregateHistoryCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAggregate>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).aggregateHistoryCall(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineBlindTransferCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blindTransferCall(
      id: string,
      body: EngineBlindTransferCallRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).blindTransferCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirmPush(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).confirmPush(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create e call
     * @param {EngineCreateCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCall(
      body: EngineCreateCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCreateCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).createCall(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} callId
     * @param {EngineCreateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCallAnnotation(
      callId: string,
      body: EngineCreateCallAnnotationRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCallAnnotation>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).createCallAnnotation(callId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCallAnnotation(
      callId: string,
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCallAnnotation>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).deleteCallAnnotation(callId, id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineDtmfCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dtmfCall(
      id: string,
      body: EngineDtmfCallRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).dtmfCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineEavesdropCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eavesdropCall(
      id: string,
      body: EngineEavesdropCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCreateCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).eavesdropCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineHangupCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hangupCall(
      id: string,
      body: EngineHangupCallRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).hangupCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async holdCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineHoldCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).holdCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readCall(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineActiveCall>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).readCall(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {boolean} [existsFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {Array<string>} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [supervisorId]
     * @param {Array<string>} [state]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchActiveCall(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      existsFile?: boolean,
      domainId?: string,
      number?: string,
      direction?: Array<string>,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      supervisorId?: Array<string>,
      state?: Array<string>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineListCall>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).searchActiveCall(
        page,
        size,
        q,
        sort,
        fields,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        existsFile,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        supervisorId,
        state,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of call
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {boolean} [hasFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {string} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [transferFrom]
     * @param {Array<string>} [transferTo]
     * @param {Array<string>} [dependencyId]
     * @param {Array<string>} [tags]
     * @param {Array<string>} [amdResult]
     * @param {string} [fts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchHistoryCall(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      hasFile?: boolean,
      domainId?: string,
      number?: string,
      direction?: string,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      id?: Array<string>,
      transferFrom?: Array<string>,
      transferTo?: Array<string>,
      dependencyId?: Array<string>,
      tags?: Array<string>,
      amdResult?: Array<string>,
      fts?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListHistoryCall>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).searchHistoryCall(
        page,
        size,
        q,
        sort,
        fields,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        hasFile,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        id,
        transferFrom,
        transferTo,
        dependencyId,
        tags,
        amdResult,
        fts,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unHoldCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineHoldCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).unHoldCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {EngineUpdateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCallAnnotation(
      callId: string,
      id: string,
      body: EngineUpdateCallAnnotationRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCallAnnotation>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).updateCallAnnotation(callId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * CallServiceApi - factory interface
 * @export
 */
export const CallServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {EngineAggregateHistoryCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    aggregateHistoryCall(
      body: EngineAggregateHistoryCallRequest,
      options?: any
    ): AxiosPromise<EngineListAggregate> {
      return CallServiceApiFp(configuration)
        .aggregateHistoryCall(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineBlindTransferCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blindTransferCall(
      id: string,
      body: EngineBlindTransferCallRequest,
      options?: any
    ): AxiosPromise<object> {
      return CallServiceApiFp(configuration)
        .blindTransferCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmPush(id: string, options?: any): AxiosPromise<object> {
      return CallServiceApiFp(configuration)
        .confirmPush(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create e call
     * @param {EngineCreateCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCall(
      body: EngineCreateCallRequest,
      options?: any
    ): AxiosPromise<EngineCreateCallResponse> {
      return CallServiceApiFp(configuration)
        .createCall(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} callId
     * @param {EngineCreateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCallAnnotation(
      callId: string,
      body: EngineCreateCallAnnotationRequest,
      options?: any
    ): AxiosPromise<EngineCallAnnotation> {
      return CallServiceApiFp(configuration)
        .createCallAnnotation(callId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCallAnnotation(
      callId: string,
      id: string,
      options?: any
    ): AxiosPromise<EngineCallAnnotation> {
      return CallServiceApiFp(configuration)
        .deleteCallAnnotation(callId, id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineDtmfCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dtmfCall(
      id: string,
      body: EngineDtmfCallRequest,
      options?: any
    ): AxiosPromise<object> {
      return CallServiceApiFp(configuration)
        .dtmfCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineEavesdropCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eavesdropCall(
      id: string,
      body: EngineEavesdropCallRequest,
      options?: any
    ): AxiosPromise<EngineCreateCallResponse> {
      return CallServiceApiFp(configuration)
        .eavesdropCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineHangupCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hangupCall(
      id: string,
      body: EngineHangupCallRequest,
      options?: any
    ): AxiosPromise<object> {
      return CallServiceApiFp(configuration)
        .hangupCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    holdCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): AxiosPromise<EngineHoldCallResponse> {
      return CallServiceApiFp(configuration)
        .holdCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readCall(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineActiveCall> {
      return CallServiceApiFp(configuration)
        .readCall(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {boolean} [existsFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {Array<string>} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [supervisorId]
     * @param {Array<string>} [state]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchActiveCall(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      existsFile?: boolean,
      domainId?: string,
      number?: string,
      direction?: Array<string>,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      supervisorId?: Array<string>,
      state?: Array<string>,
      options?: any
    ): AxiosPromise<EngineListCall> {
      return CallServiceApiFp(configuration)
        .searchActiveCall(
          page,
          size,
          q,
          sort,
          fields,
          createdAtFrom,
          createdAtTo,
          userId,
          agentId,
          queueId,
          teamId,
          memberId,
          gatewayId,
          durationFrom,
          durationTo,
          skipParent,
          parentId,
          cause,
          existsFile,
          domainId,
          number,
          direction,
          answeredAtFrom,
          answeredAtTo,
          missed,
          storedAtFrom,
          storedAtTo,
          supervisorId,
          state,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of call
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {Array<string>} [cause]
     * @param {boolean} [hasFile]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {string} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [transferFrom]
     * @param {Array<string>} [transferTo]
     * @param {Array<string>} [dependencyId]
     * @param {Array<string>} [tags]
     * @param {Array<string>} [amdResult]
     * @param {string} [fts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchHistoryCall(
      page?: number,
      size?: number,
      q?: string,
      sort?: string,
      fields?: Array<string>,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: Array<string>,
      hasFile?: boolean,
      domainId?: string,
      number?: string,
      direction?: string,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      id?: Array<string>,
      transferFrom?: Array<string>,
      transferTo?: Array<string>,
      dependencyId?: Array<string>,
      tags?: Array<string>,
      amdResult?: Array<string>,
      fts?: string,
      options?: any
    ): AxiosPromise<EngineListHistoryCall> {
      return CallServiceApiFp(configuration)
        .searchHistoryCall(
          page,
          size,
          q,
          sort,
          fields,
          createdAtFrom,
          createdAtTo,
          userId,
          agentId,
          queueId,
          teamId,
          memberId,
          gatewayId,
          durationFrom,
          durationTo,
          skipParent,
          parentId,
          cause,
          hasFile,
          domainId,
          number,
          direction,
          answeredAtFrom,
          answeredAtTo,
          missed,
          storedAtFrom,
          storedAtTo,
          id,
          transferFrom,
          transferTo,
          dependencyId,
          tags,
          amdResult,
          fts,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unHoldCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): AxiosPromise<EngineHoldCallResponse> {
      return CallServiceApiFp(configuration)
        .unHoldCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} callId
     * @param {string} id
     * @param {EngineUpdateCallAnnotationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCallAnnotation(
      callId: string,
      id: string,
      body: EngineUpdateCallAnnotationRequest,
      options?: any
    ): AxiosPromise<EngineCallAnnotation> {
      return CallServiceApiFp(configuration)
        .updateCallAnnotation(callId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CallServiceApi - object-oriented interface
 * @export
 * @class CallServiceApi
 * @extends {BaseAPI}
 */
export class CallServiceApi extends BaseAPI {
  /**
   *
   * @param {EngineAggregateHistoryCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public aggregateHistoryCall(
    body: EngineAggregateHistoryCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .aggregateHistoryCall(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineBlindTransferCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public blindTransferCall(
    id: string,
    body: EngineBlindTransferCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .blindTransferCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Call item
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public confirmPush(id: string, options?: any) {
    return CallServiceApiFp(this.configuration)
      .confirmPush(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create e call
   * @param {EngineCreateCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public createCall(body: EngineCreateCallRequest, options?: any) {
    return CallServiceApiFp(this.configuration)
      .createCall(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} callId
   * @param {EngineCreateCallAnnotationRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public createCallAnnotation(
    callId: string,
    body: EngineCreateCallAnnotationRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .createCallAnnotation(callId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} callId
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public deleteCallAnnotation(callId: string, id: string, options?: any) {
    return CallServiceApiFp(this.configuration)
      .deleteCallAnnotation(callId, id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineDtmfCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public dtmfCall(id: string, body: EngineDtmfCallRequest, options?: any) {
    return CallServiceApiFp(this.configuration)
      .dtmfCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineEavesdropCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public eavesdropCall(
    id: string,
    body: EngineEavesdropCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .eavesdropCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineHangupCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public hangupCall(id: string, body: EngineHangupCallRequest, options?: any) {
    return CallServiceApiFp(this.configuration)
      .hangupCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineUserCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public holdCall(id: string, body: EngineUserCallRequest, options?: any) {
    return CallServiceApiFp(this.configuration)
      .holdCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Call item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public readCall(id: string, domainId?: string, options?: any) {
    return CallServiceApiFp(this.configuration)
      .readCall(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [sort]
   * @param {Array<string>} [fields]
   * @param {string} [createdAtFrom]
   * @param {string} [createdAtTo]
   * @param {Array<string>} [userId]
   * @param {Array<string>} [agentId]
   * @param {Array<string>} [queueId]
   * @param {Array<string>} [teamId]
   * @param {Array<string>} [memberId]
   * @param {Array<string>} [gatewayId]
   * @param {string} [durationFrom]
   * @param {string} [durationTo]
   * @param {boolean} [skipParent]
   * @param {string} [parentId]
   * @param {Array<string>} [cause]
   * @param {boolean} [existsFile]
   * @param {string} [domainId]
   * @param {string} [number]
   * @param {Array<string>} [direction]
   * @param {string} [answeredAtFrom]
   * @param {string} [answeredAtTo]
   * @param {boolean} [missed]
   * @param {string} [storedAtFrom]
   * @param {string} [storedAtTo]
   * @param {Array<string>} [supervisorId]
   * @param {Array<string>} [state]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public searchActiveCall(
    page?: number,
    size?: number,
    q?: string,
    sort?: string,
    fields?: Array<string>,
    createdAtFrom?: string,
    createdAtTo?: string,
    userId?: Array<string>,
    agentId?: Array<string>,
    queueId?: Array<string>,
    teamId?: Array<string>,
    memberId?: Array<string>,
    gatewayId?: Array<string>,
    durationFrom?: string,
    durationTo?: string,
    skipParent?: boolean,
    parentId?: string,
    cause?: Array<string>,
    existsFile?: boolean,
    domainId?: string,
    number?: string,
    direction?: Array<string>,
    answeredAtFrom?: string,
    answeredAtTo?: string,
    missed?: boolean,
    storedAtFrom?: string,
    storedAtTo?: string,
    supervisorId?: Array<string>,
    state?: Array<string>,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .searchActiveCall(
        page,
        size,
        q,
        sort,
        fields,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        existsFile,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        supervisorId,
        state,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of call
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [sort]
   * @param {Array<string>} [fields]
   * @param {string} [createdAtFrom]
   * @param {string} [createdAtTo]
   * @param {Array<string>} [userId]
   * @param {Array<string>} [agentId]
   * @param {Array<string>} [queueId]
   * @param {Array<string>} [teamId]
   * @param {Array<string>} [memberId]
   * @param {Array<string>} [gatewayId]
   * @param {string} [durationFrom]
   * @param {string} [durationTo]
   * @param {boolean} [skipParent]
   * @param {string} [parentId]
   * @param {Array<string>} [cause]
   * @param {boolean} [hasFile]
   * @param {string} [domainId]
   * @param {string} [number]
   * @param {string} [direction]
   * @param {string} [answeredAtFrom]
   * @param {string} [answeredAtTo]
   * @param {boolean} [missed]
   * @param {string} [storedAtFrom]
   * @param {string} [storedAtTo]
   * @param {Array<string>} [id]
   * @param {Array<string>} [transferFrom]
   * @param {Array<string>} [transferTo]
   * @param {Array<string>} [dependencyId]
   * @param {Array<string>} [tags]
   * @param {Array<string>} [amdResult]
   * @param {string} [fts]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public searchHistoryCall(
    page?: number,
    size?: number,
    q?: string,
    sort?: string,
    fields?: Array<string>,
    createdAtFrom?: string,
    createdAtTo?: string,
    userId?: Array<string>,
    agentId?: Array<string>,
    queueId?: Array<string>,
    teamId?: Array<string>,
    memberId?: Array<string>,
    gatewayId?: Array<string>,
    durationFrom?: string,
    durationTo?: string,
    skipParent?: boolean,
    parentId?: string,
    cause?: Array<string>,
    hasFile?: boolean,
    domainId?: string,
    number?: string,
    direction?: string,
    answeredAtFrom?: string,
    answeredAtTo?: string,
    missed?: boolean,
    storedAtFrom?: string,
    storedAtTo?: string,
    id?: Array<string>,
    transferFrom?: Array<string>,
    transferTo?: Array<string>,
    dependencyId?: Array<string>,
    tags?: Array<string>,
    amdResult?: Array<string>,
    fts?: string,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .searchHistoryCall(
        page,
        size,
        q,
        sort,
        fields,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        hasFile,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        id,
        transferFrom,
        transferTo,
        dependencyId,
        tags,
        amdResult,
        fts,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineUserCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public unHoldCall(id: string, body: EngineUserCallRequest, options?: any) {
    return CallServiceApiFp(this.configuration)
      .unHoldCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} callId
   * @param {string} id
   * @param {EngineUpdateCallAnnotationRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public updateCallAnnotation(
    callId: string,
    id: string,
    body: EngineUpdateCallAnnotationRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .updateCallAnnotation(callId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
