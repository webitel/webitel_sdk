// tslint:disable
/**
 * Webitel API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 24.04.0
 * Contact: support@webitel.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
import { Configuration } from '../configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base'
// @ts-ignore
import { ApiCreateDeviceResponse } from '../api'
// @ts-ignore
import { ApiDeleteDeviceResponse } from '../api'
// @ts-ignore
import { ApiDevice } from '../api'
// @ts-ignore
import { ApiDeviceAuditResponse } from '../api'
// @ts-ignore
import { ApiListRegistrationsResponse } from '../api'
// @ts-ignore
import { ApiReadDeviceResponse } from '../api'
// @ts-ignore
import { ApiSearchDeviceResponse } from '../api'
// @ts-ignore
import { ApiUpdateDeviceResponse } from '../api'
// @ts-ignore
import { DeviceProfile } from '../api'
// @ts-ignore
import { DeviceProfile1 } from '../api'
/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {ApiDevice} device string password &#x3D; 2;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDevice: async (
      device: ApiDevice,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'device' is not null or undefined
      if (device === null || device === undefined) {
        throw new RequiredError(
          'device',
          'Required parameter device was null or undefined when calling createDevice.'
        )
      }
      const localVarPath = `/devices`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof device !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(device !== undefined ? device : {})
        : device || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {boolean} [permanent]
     * @param {Array<string>} [ids] bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDevice: async (
      id: string,
      permanent?: boolean,
      ids?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteDevice.'
        )
      }
      const localVarPath = `/devices/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (permanent !== undefined) {
        localVarQueryParameter['permanent'] = permanent
      }

      if (ids) {
        localVarQueryParameter['ids'] = ids
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Array<string>} ids bulk
     * @param {string} [id]
     * @param {boolean} [permanent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDevice2: async (
      ids: Array<string>,
      id?: string,
      permanent?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          'ids',
          'Required parameter ids was null or undefined when calling deleteDevice2.'
        )
      }
      const localVarPath = `/devices`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (permanent !== undefined) {
        localVarQueryParameter['permanent'] = permanent
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof ids !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(ids !== undefined ? ids : {})
        : ids || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} deviceId Object ID
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [deviceName] Display Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRegistrations: async (
      deviceId: string,
      userId?: string,
      userName?: string,
      deviceName?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'deviceId' is not null or undefined
      if (deviceId === null || deviceId === undefined) {
        throw new RequiredError(
          'deviceId',
          'Required parameter deviceId was null or undefined when calling listRegistrations.'
        )
      }
      const localVarPath = `/devices/{device.id}/registered`.replace(
        `{${'device.id'}}`,
        encodeURIComponent(String(deviceId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (userId !== undefined) {
        localVarQueryParameter['user.id'] = userId
      }

      if (userName !== undefined) {
        localVarQueryParameter['user.name'] = userName
      }

      if (deviceName !== undefined) {
        localVarQueryParameter['device.name'] = deviceName
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {Array<string>} [fields] output selection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDevice: async (
      id: string,
      fields?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readDevice.'
        )
      }
      const localVarPath = `/devices/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} [size] ----- Select Options -------------------------  default: 16
     * @param {number} [page] default: 1
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [ids] ----- Search Basic Filters ---------------------------  selection: by unique identifier
     * @param {string} [q] term-of-search: lookup[name,account,hotdesk,brand,model,mac,ip]
     * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
     * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
     * @param {string} [account] ----- Device-Specific Filters ----------------  substring like \&#39;%name%\&#39;
     * @param {string} [hotdesk] filter: has hotdesk (&#x3D;pattern); is hotdesk (&#x3D;*)
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [mac] filter: by MAC address
     * @param {string} [ip] filter: by IP address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDevice: async (
      size?: number,
      page?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      ids?: Array<string>,
      q?: string,
      name?: string,
      access?: string,
      account?: string,
      hotdesk?: string,
      userId?: string,
      userName?: string,
      mac?: string,
      ip?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/devices`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (ids) {
        localVarQueryParameter['ids'] = ids
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (access !== undefined) {
        localVarQueryParameter['access'] = access
      }

      if (account !== undefined) {
        localVarQueryParameter['account'] = account
      }

      if (hotdesk !== undefined) {
        localVarQueryParameter['hotdesk'] = hotdesk
      }

      if (userId !== undefined) {
        localVarQueryParameter['user.id'] = userId
      }

      if (userName !== undefined) {
        localVarQueryParameter['user.name'] = userName
      }

      if (mac !== undefined) {
        localVarQueryParameter['mac'] = mac
      }

      if (ip !== undefined) {
        localVarQueryParameter['ip'] = ip
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ----- Details (1:M) ----------------------------------------------
     * @param {string} deviceId Object ID
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [deviceName] Display Name
     * @param {string} [timeFrom] Filter: timing range (optional)  unix milliseconds
     * @param {string} [timeTill] unix milliseconds
     * @param {Array<string>} [fields] Search Options
     * @param {Array<string>} [sort]
     * @param {number} [size]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDeviceAudit: async (
      deviceId: string,
      userId?: string,
      userName?: string,
      deviceName?: string,
      timeFrom?: string,
      timeTill?: string,
      fields?: Array<string>,
      sort?: Array<string>,
      size?: number,
      page?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'deviceId' is not null or undefined
      if (deviceId === null || deviceId === undefined) {
        throw new RequiredError(
          'deviceId',
          'Required parameter deviceId was null or undefined when calling searchDeviceAudit.'
        )
      }
      const localVarPath = `/devices/{device.id}/users/audit`.replace(
        `{${'device.id'}}`,
        encodeURIComponent(String(deviceId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (userId !== undefined) {
        localVarQueryParameter['user.id'] = userId
      }

      if (userName !== undefined) {
        localVarQueryParameter['user.name'] = userName
      }

      if (deviceName !== undefined) {
        localVarQueryParameter['device.name'] = deviceName
      }

      if (timeFrom !== undefined) {
        localVarQueryParameter['time_from'] = timeFrom
      }

      if (timeTill !== undefined) {
        localVarQueryParameter['time_till'] = timeTill
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} deviceId object id
     * @param {DeviceProfile} device
     * @param {Array<string>} [fields] PATCH: partial update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDevice: async (
      deviceId: string,
      device: DeviceProfile,
      fields?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'deviceId' is not null or undefined
      if (deviceId === null || deviceId === undefined) {
        throw new RequiredError(
          'deviceId',
          'Required parameter deviceId was null or undefined when calling updateDevice.'
        )
      }
      // verify required parameter 'device' is not null or undefined
      if (device === null || device === undefined) {
        throw new RequiredError(
          'device',
          'Required parameter device was null or undefined when calling updateDevice.'
        )
      }
      const localVarPath = `/devices/{device.id}`.replace(
        `{${'device.id'}}`,
        encodeURIComponent(String(deviceId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof device !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(device !== undefined ? device : {})
        : device || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} deviceId object id
     * @param {DeviceProfile1} device
     * @param {Array<string>} [fields] PATCH: partial update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDevice2: async (
      deviceId: string,
      device: DeviceProfile1,
      fields?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'deviceId' is not null or undefined
      if (deviceId === null || deviceId === undefined) {
        throw new RequiredError(
          'deviceId',
          'Required parameter deviceId was null or undefined when calling updateDevice2.'
        )
      }
      // verify required parameter 'device' is not null or undefined
      if (device === null || device === undefined) {
        throw new RequiredError(
          'device',
          'Required parameter device was null or undefined when calling updateDevice2.'
        )
      }
      const localVarPath = `/devices/{device.id}`.replace(
        `{${'device.id'}}`,
        encodeURIComponent(String(deviceId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof device !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(device !== undefined ? device : {})
        : device || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {ApiDevice} device string password &#x3D; 2;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDevice(
      device: ApiDevice,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiCreateDeviceResponse>
    > {
      const localVarAxiosArgs = await DevicesApiAxiosParamCreator(
        configuration
      ).createDevice(device, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {boolean} [permanent]
     * @param {Array<string>} [ids] bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDevice(
      id: string,
      permanent?: boolean,
      ids?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiDeleteDeviceResponse>
    > {
      const localVarAxiosArgs = await DevicesApiAxiosParamCreator(
        configuration
      ).deleteDevice(id, permanent, ids, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {Array<string>} ids bulk
     * @param {string} [id]
     * @param {boolean} [permanent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDevice2(
      ids: Array<string>,
      id?: string,
      permanent?: boolean,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiDeleteDeviceResponse>
    > {
      const localVarAxiosArgs = await DevicesApiAxiosParamCreator(
        configuration
      ).deleteDevice2(ids, id, permanent, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} deviceId Object ID
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [deviceName] Display Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRegistrations(
      deviceId: string,
      userId?: string,
      userName?: string,
      deviceName?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiListRegistrationsResponse>
    > {
      const localVarAxiosArgs = await DevicesApiAxiosParamCreator(
        configuration
      ).listRegistrations(deviceId, userId, userName, deviceName, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {Array<string>} [fields] output selection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readDevice(
      id: string,
      fields?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiReadDeviceResponse>
    > {
      const localVarAxiosArgs = await DevicesApiAxiosParamCreator(
        configuration
      ).readDevice(id, fields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {number} [size] ----- Select Options -------------------------  default: 16
     * @param {number} [page] default: 1
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [ids] ----- Search Basic Filters ---------------------------  selection: by unique identifier
     * @param {string} [q] term-of-search: lookup[name,account,hotdesk,brand,model,mac,ip]
     * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
     * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
     * @param {string} [account] ----- Device-Specific Filters ----------------  substring like \&#39;%name%\&#39;
     * @param {string} [hotdesk] filter: has hotdesk (&#x3D;pattern); is hotdesk (&#x3D;*)
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [mac] filter: by MAC address
     * @param {string} [ip] filter: by IP address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchDevice(
      size?: number,
      page?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      ids?: Array<string>,
      q?: string,
      name?: string,
      access?: string,
      account?: string,
      hotdesk?: string,
      userId?: string,
      userName?: string,
      mac?: string,
      ip?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiSearchDeviceResponse>
    > {
      const localVarAxiosArgs = await DevicesApiAxiosParamCreator(
        configuration
      ).searchDevice(
        size,
        page,
        fields,
        sort,
        ids,
        q,
        name,
        access,
        account,
        hotdesk,
        userId,
        userName,
        mac,
        ip,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary ----- Details (1:M) ----------------------------------------------
     * @param {string} deviceId Object ID
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [deviceName] Display Name
     * @param {string} [timeFrom] Filter: timing range (optional)  unix milliseconds
     * @param {string} [timeTill] unix milliseconds
     * @param {Array<string>} [fields] Search Options
     * @param {Array<string>} [sort]
     * @param {number} [size]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchDeviceAudit(
      deviceId: string,
      userId?: string,
      userName?: string,
      deviceName?: string,
      timeFrom?: string,
      timeTill?: string,
      fields?: Array<string>,
      sort?: Array<string>,
      size?: number,
      page?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiDeviceAuditResponse>
    > {
      const localVarAxiosArgs = await DevicesApiAxiosParamCreator(
        configuration
      ).searchDeviceAudit(
        deviceId,
        userId,
        userName,
        deviceName,
        timeFrom,
        timeTill,
        fields,
        sort,
        size,
        page,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} deviceId object id
     * @param {DeviceProfile} device
     * @param {Array<string>} [fields] PATCH: partial update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDevice(
      deviceId: string,
      device: DeviceProfile,
      fields?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiUpdateDeviceResponse>
    > {
      const localVarAxiosArgs = await DevicesApiAxiosParamCreator(
        configuration
      ).updateDevice(deviceId, device, fields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} deviceId object id
     * @param {DeviceProfile1} device
     * @param {Array<string>} [fields] PATCH: partial update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDevice2(
      deviceId: string,
      device: DeviceProfile1,
      fields?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiUpdateDeviceResponse>
    > {
      const localVarAxiosArgs = await DevicesApiAxiosParamCreator(
        configuration
      ).updateDevice2(deviceId, device, fields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {ApiDevice} device string password &#x3D; 2;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDevice(
      device: ApiDevice,
      options?: any
    ): AxiosPromise<ApiCreateDeviceResponse> {
      return DevicesApiFp(configuration)
        .createDevice(device, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {boolean} [permanent]
     * @param {Array<string>} [ids] bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDevice(
      id: string,
      permanent?: boolean,
      ids?: Array<string>,
      options?: any
    ): AxiosPromise<ApiDeleteDeviceResponse> {
      return DevicesApiFp(configuration)
        .deleteDevice(id, permanent, ids, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {Array<string>} ids bulk
     * @param {string} [id]
     * @param {boolean} [permanent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDevice2(
      ids: Array<string>,
      id?: string,
      permanent?: boolean,
      options?: any
    ): AxiosPromise<ApiDeleteDeviceResponse> {
      return DevicesApiFp(configuration)
        .deleteDevice2(ids, id, permanent, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} deviceId Object ID
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [deviceName] Display Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRegistrations(
      deviceId: string,
      userId?: string,
      userName?: string,
      deviceName?: string,
      options?: any
    ): AxiosPromise<ApiListRegistrationsResponse> {
      return DevicesApiFp(configuration)
        .listRegistrations(deviceId, userId, userName, deviceName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {Array<string>} [fields] output selection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDevice(
      id: string,
      fields?: Array<string>,
      options?: any
    ): AxiosPromise<ApiReadDeviceResponse> {
      return DevicesApiFp(configuration)
        .readDevice(id, fields, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} [size] ----- Select Options -------------------------  default: 16
     * @param {number} [page] default: 1
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [ids] ----- Search Basic Filters ---------------------------  selection: by unique identifier
     * @param {string} [q] term-of-search: lookup[name,account,hotdesk,brand,model,mac,ip]
     * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
     * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
     * @param {string} [account] ----- Device-Specific Filters ----------------  substring like \&#39;%name%\&#39;
     * @param {string} [hotdesk] filter: has hotdesk (&#x3D;pattern); is hotdesk (&#x3D;*)
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [mac] filter: by MAC address
     * @param {string} [ip] filter: by IP address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDevice(
      size?: number,
      page?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      ids?: Array<string>,
      q?: string,
      name?: string,
      access?: string,
      account?: string,
      hotdesk?: string,
      userId?: string,
      userName?: string,
      mac?: string,
      ip?: string,
      options?: any
    ): AxiosPromise<ApiSearchDeviceResponse> {
      return DevicesApiFp(configuration)
        .searchDevice(
          size,
          page,
          fields,
          sort,
          ids,
          q,
          name,
          access,
          account,
          hotdesk,
          userId,
          userName,
          mac,
          ip,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ----- Details (1:M) ----------------------------------------------
     * @param {string} deviceId Object ID
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [deviceName] Display Name
     * @param {string} [timeFrom] Filter: timing range (optional)  unix milliseconds
     * @param {string} [timeTill] unix milliseconds
     * @param {Array<string>} [fields] Search Options
     * @param {Array<string>} [sort]
     * @param {number} [size]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDeviceAudit(
      deviceId: string,
      userId?: string,
      userName?: string,
      deviceName?: string,
      timeFrom?: string,
      timeTill?: string,
      fields?: Array<string>,
      sort?: Array<string>,
      size?: number,
      page?: number,
      options?: any
    ): AxiosPromise<ApiDeviceAuditResponse> {
      return DevicesApiFp(configuration)
        .searchDeviceAudit(
          deviceId,
          userId,
          userName,
          deviceName,
          timeFrom,
          timeTill,
          fields,
          sort,
          size,
          page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} deviceId object id
     * @param {DeviceProfile} device
     * @param {Array<string>} [fields] PATCH: partial update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDevice(
      deviceId: string,
      device: DeviceProfile,
      fields?: Array<string>,
      options?: any
    ): AxiosPromise<ApiUpdateDeviceResponse> {
      return DevicesApiFp(configuration)
        .updateDevice(deviceId, device, fields, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} deviceId object id
     * @param {DeviceProfile1} device
     * @param {Array<string>} [fields] PATCH: partial update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDevice2(
      deviceId: string,
      device: DeviceProfile1,
      fields?: Array<string>,
      options?: any
    ): AxiosPromise<ApiUpdateDeviceResponse> {
      return DevicesApiFp(configuration)
        .updateDevice2(deviceId, device, fields, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
  /**
   *
   * @param {ApiDevice} device string password &#x3D; 2;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DevicesApi
   */
  public createDevice(device: ApiDevice, options?: any) {
    return DevicesApiFp(this.configuration)
      .createDevice(device, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {boolean} [permanent]
   * @param {Array<string>} [ids] bulk
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DevicesApi
   */
  public deleteDevice(
    id: string,
    permanent?: boolean,
    ids?: Array<string>,
    options?: any
  ) {
    return DevicesApiFp(this.configuration)
      .deleteDevice(id, permanent, ids, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {Array<string>} ids bulk
   * @param {string} [id]
   * @param {boolean} [permanent]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DevicesApi
   */
  public deleteDevice2(
    ids: Array<string>,
    id?: string,
    permanent?: boolean,
    options?: any
  ) {
    return DevicesApiFp(this.configuration)
      .deleteDevice2(ids, id, permanent, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} deviceId Object ID
   * @param {string} [userId] Object ID
   * @param {string} [userName] Display Name
   * @param {string} [deviceName] Display Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DevicesApi
   */
  public listRegistrations(
    deviceId: string,
    userId?: string,
    userName?: string,
    deviceName?: string,
    options?: any
  ) {
    return DevicesApiFp(this.configuration)
      .listRegistrations(deviceId, userId, userName, deviceName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {Array<string>} [fields] output selection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DevicesApi
   */
  public readDevice(id: string, fields?: Array<string>, options?: any) {
    return DevicesApiFp(this.configuration)
      .readDevice(id, fields, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [size] ----- Select Options -------------------------  default: 16
   * @param {number} [page] default: 1
   * @param {Array<string>} [fields] attributes list
   * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
   * @param {Array<string>} [ids] ----- Search Basic Filters ---------------------------  selection: by unique identifier
   * @param {string} [q] term-of-search: lookup[name,account,hotdesk,brand,model,mac,ip]
   * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
   * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
   * @param {string} [account] ----- Device-Specific Filters ----------------  substring like \&#39;%name%\&#39;
   * @param {string} [hotdesk] filter: has hotdesk (&#x3D;pattern); is hotdesk (&#x3D;*)
   * @param {string} [userId] Object ID
   * @param {string} [userName] Display Name
   * @param {string} [mac] filter: by MAC address
   * @param {string} [ip] filter: by IP address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DevicesApi
   */
  public searchDevice(
    size?: number,
    page?: number,
    fields?: Array<string>,
    sort?: Array<string>,
    ids?: Array<string>,
    q?: string,
    name?: string,
    access?: string,
    account?: string,
    hotdesk?: string,
    userId?: string,
    userName?: string,
    mac?: string,
    ip?: string,
    options?: any
  ) {
    return DevicesApiFp(this.configuration)
      .searchDevice(
        size,
        page,
        fields,
        sort,
        ids,
        q,
        name,
        access,
        account,
        hotdesk,
        userId,
        userName,
        mac,
        ip,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ----- Details (1:M) ----------------------------------------------
   * @param {string} deviceId Object ID
   * @param {string} [userId] Object ID
   * @param {string} [userName] Display Name
   * @param {string} [deviceName] Display Name
   * @param {string} [timeFrom] Filter: timing range (optional)  unix milliseconds
   * @param {string} [timeTill] unix milliseconds
   * @param {Array<string>} [fields] Search Options
   * @param {Array<string>} [sort]
   * @param {number} [size]
   * @param {number} [page]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DevicesApi
   */
  public searchDeviceAudit(
    deviceId: string,
    userId?: string,
    userName?: string,
    deviceName?: string,
    timeFrom?: string,
    timeTill?: string,
    fields?: Array<string>,
    sort?: Array<string>,
    size?: number,
    page?: number,
    options?: any
  ) {
    return DevicesApiFp(this.configuration)
      .searchDeviceAudit(
        deviceId,
        userId,
        userName,
        deviceName,
        timeFrom,
        timeTill,
        fields,
        sort,
        size,
        page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} deviceId object id
   * @param {DeviceProfile} device
   * @param {Array<string>} [fields] PATCH: partial update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DevicesApi
   */
  public updateDevice(
    deviceId: string,
    device: DeviceProfile,
    fields?: Array<string>,
    options?: any
  ) {
    return DevicesApiFp(this.configuration)
      .updateDevice(deviceId, device, fields, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} deviceId object id
   * @param {DeviceProfile1} device
   * @param {Array<string>} [fields] PATCH: partial update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DevicesApi
   */
  public updateDevice2(
    deviceId: string,
    device: DeviceProfile1,
    fields?: Array<string>,
    options?: any
  ) {
    return DevicesApiFp(this.configuration)
      .updateDevice2(deviceId, device, fields, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
