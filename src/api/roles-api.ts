// tslint:disable
/**
 * Webitel API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 24.04.0
 * Contact: support@webitel.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
import { Configuration } from '../configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base'
// @ts-ignore
import { ApiCreateRoleRequest } from '../api'
// @ts-ignore
import { ApiCreateRoleResponse } from '../api'
// @ts-ignore
import { ApiDeleteRoleResponse } from '../api'
// @ts-ignore
import { ApiReadRoleResponse } from '../api'
// @ts-ignore
import { ApiRoleMetadataResponse } from '../api'
// @ts-ignore
import { ApiRolesUpdateRoleBody } from '../api'
// @ts-ignore
import { ApiSearchRolesResponse } from '../api'
// @ts-ignore
import { ApiUpdateRoleResponse } from '../api'
/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {ApiCreateRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole: async (
      body: ApiCreateRoleRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createRole.'
        )
      }
      const localVarPath = `/roles`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id DELETE /roles/{id}
     * @param {Array<string>} [ids] POST /roles/delete {\&quot;ids\&quot;}
     * @param {boolean} [permanent] deleteOrMark \&#39;deleted\&#39; ?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole: async (
      id: string,
      ids?: Array<string>,
      permanent?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteRole.'
        )
      }
      const localVarPath = `/roles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (ids) {
        localVarQueryParameter['ids'] = ids
      }

      if (permanent !== undefined) {
        localVarQueryParameter['permanent'] = permanent
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id role.id
     * @param {Array<string>} [fields] select projection  select: output (fields,...)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readRole: async (
      id: string,
      fields?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readRole.'
        )
      }
      const localVarPath = `/roles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [id] Optional. Unique ID of metadata role owner
     * @param {string} [key] Optional. Partial metadata document key name
     * @param {'NULL_VALUE'} [mergeNullValue] Represents a null value.   - NULL_VALUE: Null value.
     * @param {number} [mergeNumberValue] Represents a double value.
     * @param {string} [mergeStringValue] Represents a string value.
     * @param {boolean} [mergeBoolValue] Represents a boolean value.
     * @param {object} [mergeStructValue] Represents a structured value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleMetadata: async (
      id?: string,
      key?: string,
      mergeNullValue?: 'NULL_VALUE',
      mergeNumberValue?: number,
      mergeStringValue?: string,
      mergeBoolValue?: boolean,
      mergeStructValue?: object,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/roles/metadata`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (key !== undefined) {
        localVarQueryParameter['key'] = key
      }

      if (mergeNullValue !== undefined) {
        localVarQueryParameter['merge.null_value'] = mergeNullValue
      }

      if (mergeNumberValue !== undefined) {
        localVarQueryParameter['merge.number_value'] = mergeNumberValue
      }

      if (mergeStringValue !== undefined) {
        localVarQueryParameter['merge.string_value'] = mergeStringValue
      }

      if (mergeBoolValue !== undefined) {
        localVarQueryParameter['merge.bool_value'] = mergeBoolValue
      }

      if (mergeStructValue !== undefined) {
        localVarQueryParameter['merge.struct_value'] = mergeStructValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'contacts' | 'cc_list' | 'cc_bucket' | 'calendars' | 'devices' | 'cc_agent' | 'cc_team' | 'cc_resource' | 'cc_resource_group' | 'cc_queue' | 'roles' | 'users' | 'cognitive_profile'} object bool admin &#x3D; 4;  // filter: where CURRENT user is \&#39;ADMIN\&#39; of REQUIRED !
     * @param {string} recordId identifier
     * @param {Array<string>} [ids] ----- Role-specific Filters ----------------- //  filter: .id &#x3D; any(:ids...)
     * @param {string} [name] filter: group name like
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [q] filter: term of search (name, description)
     * @param {string} [recordName] display name
     * @param {Array<string>} [fields] controls  output
     * @param {Array<string>} [sort] sort: \&quot;field\&quot; asc; \&quot;!field\&quot; desc
     * @param {number} [page] page number
     * @param {number} [size] page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRecordAvailableRoles: async (
      object:
        | 'contacts'
        | 'cc_list'
        | 'cc_bucket'
        | 'calendars'
        | 'devices'
        | 'cc_agent'
        | 'cc_team'
        | 'cc_resource'
        | 'cc_resource_group'
        | 'cc_queue'
        | 'roles'
        | 'users'
        | 'cognitive_profile',
      recordId: string,
      ids?: Array<string>,
      name?: string,
      userId?: string,
      userName?: string,
      q?: string,
      recordName?: string,
      fields?: Array<string>,
      sort?: Array<string>,
      page?: number,
      size?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'object' is not null or undefined
      if (object === null || object === undefined) {
        throw new RequiredError(
          'object',
          'Required parameter object was null or undefined when calling searchRecordAvailableRoles.'
        )
      }
      // verify required parameter 'recordId' is not null or undefined
      if (recordId === null || recordId === undefined) {
        throw new RequiredError(
          'recordId',
          'Required parameter recordId was null or undefined when calling searchRecordAvailableRoles.'
        )
      }
      const localVarPath = `/roles/objects/{object}/records/{record.id}`
        .replace(`{${'object'}}`, encodeURIComponent(String(object)))
        .replace(`{${'record.id'}}`, encodeURIComponent(String(recordId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (ids) {
        localVarQueryParameter['ids'] = ids
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (userId !== undefined) {
        localVarQueryParameter['user.id'] = userId
      }

      if (userName !== undefined) {
        localVarQueryParameter['user.name'] = userName
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (recordName !== undefined) {
        localVarQueryParameter['record.name'] = recordName
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Array<string>} [ids] ----- Role-specific Filters ----------------- //  filter: .id &#x3D; any(:ids...)
     * @param {string} [name] filter: group name like
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [q] filter: term of search (name, description)
     * @param {Array<string>} [fields] bool admin &#x3D; 4;  // filter: where CURRENT user is \&#39;ADMIN\&#39; of controls  output
     * @param {Array<string>} [sort] sort: \&quot;field\&quot; asc; \&quot;!field\&quot; desc
     * @param {number} [page] page number
     * @param {number} [size] page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRoles: async (
      ids?: Array<string>,
      name?: string,
      userId?: string,
      userName?: string,
      q?: string,
      fields?: Array<string>,
      sort?: Array<string>,
      page?: number,
      size?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/roles`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (ids) {
        localVarQueryParameter['ids'] = ids
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (userId !== undefined) {
        localVarQueryParameter['user.id'] = userId
      }

      if (userName !== undefined) {
        localVarQueryParameter['user.name'] = userName
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} roleId oid
     * @param {ApiRolesUpdateRoleBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole: async (
      roleId: string,
      body: ApiRolesUpdateRoleBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'roleId' is not null or undefined
      if (roleId === null || roleId === undefined) {
        throw new RequiredError(
          'roleId',
          'Required parameter roleId was null or undefined when calling updateRole.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateRole.'
        )
      }
      const localVarPath = `/roles/{role.id}`.replace(
        `{${'role.id'}}`,
        encodeURIComponent(String(roleId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} roleId oid
     * @param {ApiRolesUpdateRoleBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole2: async (
      roleId: string,
      body: ApiRolesUpdateRoleBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'roleId' is not null or undefined
      if (roleId === null || roleId === undefined) {
        throw new RequiredError(
          'roleId',
          'Required parameter roleId was null or undefined when calling updateRole2.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateRole2.'
        )
      }
      const localVarPath = `/roles/{role.id}`.replace(
        `{${'role.id'}}`,
        encodeURIComponent(String(roleId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {ApiCreateRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRole(
      body: ApiCreateRoleRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiCreateRoleResponse>
    > {
      const localVarAxiosArgs = await RolesApiAxiosParamCreator(
        configuration
      ).createRole(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id DELETE /roles/{id}
     * @param {Array<string>} [ids] POST /roles/delete {\&quot;ids\&quot;}
     * @param {boolean} [permanent] deleteOrMark \&#39;deleted\&#39; ?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRole(
      id: string,
      ids?: Array<string>,
      permanent?: boolean,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiDeleteRoleResponse>
    > {
      const localVarAxiosArgs = await RolesApiAxiosParamCreator(
        configuration
      ).deleteRole(id, ids, permanent, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id role.id
     * @param {Array<string>} [fields] select projection  select: output (fields,...)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readRole(
      id: string,
      fields?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiReadRoleResponse>
    > {
      const localVarAxiosArgs = await RolesApiAxiosParamCreator(
        configuration
      ).readRole(id, fields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} [id] Optional. Unique ID of metadata role owner
     * @param {string} [key] Optional. Partial metadata document key name
     * @param {'NULL_VALUE'} [mergeNullValue] Represents a null value.   - NULL_VALUE: Null value.
     * @param {number} [mergeNumberValue] Represents a double value.
     * @param {string} [mergeStringValue] Represents a string value.
     * @param {boolean} [mergeBoolValue] Represents a boolean value.
     * @param {object} [mergeStructValue] Represents a structured value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async roleMetadata(
      id?: string,
      key?: string,
      mergeNullValue?: 'NULL_VALUE',
      mergeNumberValue?: number,
      mergeStringValue?: string,
      mergeBoolValue?: boolean,
      mergeStructValue?: object,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiRoleMetadataResponse>
    > {
      const localVarAxiosArgs = await RolesApiAxiosParamCreator(
        configuration
      ).roleMetadata(
        id,
        key,
        mergeNullValue,
        mergeNumberValue,
        mergeStringValue,
        mergeBoolValue,
        mergeStructValue,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {'contacts' | 'cc_list' | 'cc_bucket' | 'calendars' | 'devices' | 'cc_agent' | 'cc_team' | 'cc_resource' | 'cc_resource_group' | 'cc_queue' | 'roles' | 'users' | 'cognitive_profile'} object bool admin &#x3D; 4;  // filter: where CURRENT user is \&#39;ADMIN\&#39; of REQUIRED !
     * @param {string} recordId identifier
     * @param {Array<string>} [ids] ----- Role-specific Filters ----------------- //  filter: .id &#x3D; any(:ids...)
     * @param {string} [name] filter: group name like
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [q] filter: term of search (name, description)
     * @param {string} [recordName] display name
     * @param {Array<string>} [fields] controls  output
     * @param {Array<string>} [sort] sort: \&quot;field\&quot; asc; \&quot;!field\&quot; desc
     * @param {number} [page] page number
     * @param {number} [size] page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchRecordAvailableRoles(
      object:
        | 'contacts'
        | 'cc_list'
        | 'cc_bucket'
        | 'calendars'
        | 'devices'
        | 'cc_agent'
        | 'cc_team'
        | 'cc_resource'
        | 'cc_resource_group'
        | 'cc_queue'
        | 'roles'
        | 'users'
        | 'cognitive_profile',
      recordId: string,
      ids?: Array<string>,
      name?: string,
      userId?: string,
      userName?: string,
      q?: string,
      recordName?: string,
      fields?: Array<string>,
      sort?: Array<string>,
      page?: number,
      size?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiSearchRolesResponse>
    > {
      const localVarAxiosArgs = await RolesApiAxiosParamCreator(
        configuration
      ).searchRecordAvailableRoles(
        object,
        recordId,
        ids,
        name,
        userId,
        userName,
        q,
        recordName,
        fields,
        sort,
        page,
        size,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {Array<string>} [ids] ----- Role-specific Filters ----------------- //  filter: .id &#x3D; any(:ids...)
     * @param {string} [name] filter: group name like
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [q] filter: term of search (name, description)
     * @param {Array<string>} [fields] bool admin &#x3D; 4;  // filter: where CURRENT user is \&#39;ADMIN\&#39; of controls  output
     * @param {Array<string>} [sort] sort: \&quot;field\&quot; asc; \&quot;!field\&quot; desc
     * @param {number} [page] page number
     * @param {number} [size] page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchRoles(
      ids?: Array<string>,
      name?: string,
      userId?: string,
      userName?: string,
      q?: string,
      fields?: Array<string>,
      sort?: Array<string>,
      page?: number,
      size?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiSearchRolesResponse>
    > {
      const localVarAxiosArgs = await RolesApiAxiosParamCreator(
        configuration
      ).searchRoles(
        ids,
        name,
        userId,
        userName,
        q,
        fields,
        sort,
        page,
        size,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} roleId oid
     * @param {ApiRolesUpdateRoleBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRole(
      roleId: string,
      body: ApiRolesUpdateRoleBody,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiUpdateRoleResponse>
    > {
      const localVarAxiosArgs = await RolesApiAxiosParamCreator(
        configuration
      ).updateRole(roleId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} roleId oid
     * @param {ApiRolesUpdateRoleBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRole2(
      roleId: string,
      body: ApiRolesUpdateRoleBody,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiUpdateRoleResponse>
    > {
      const localVarAxiosArgs = await RolesApiAxiosParamCreator(
        configuration
      ).updateRole2(roleId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {ApiCreateRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole(
      body: ApiCreateRoleRequest,
      options?: any
    ): AxiosPromise<ApiCreateRoleResponse> {
      return RolesApiFp(configuration)
        .createRole(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id DELETE /roles/{id}
     * @param {Array<string>} [ids] POST /roles/delete {\&quot;ids\&quot;}
     * @param {boolean} [permanent] deleteOrMark \&#39;deleted\&#39; ?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole(
      id: string,
      ids?: Array<string>,
      permanent?: boolean,
      options?: any
    ): AxiosPromise<ApiDeleteRoleResponse> {
      return RolesApiFp(configuration)
        .deleteRole(id, ids, permanent, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id role.id
     * @param {Array<string>} [fields] select projection  select: output (fields,...)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readRole(
      id: string,
      fields?: Array<string>,
      options?: any
    ): AxiosPromise<ApiReadRoleResponse> {
      return RolesApiFp(configuration)
        .readRole(id, fields, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} [id] Optional. Unique ID of metadata role owner
     * @param {string} [key] Optional. Partial metadata document key name
     * @param {'NULL_VALUE'} [mergeNullValue] Represents a null value.   - NULL_VALUE: Null value.
     * @param {number} [mergeNumberValue] Represents a double value.
     * @param {string} [mergeStringValue] Represents a string value.
     * @param {boolean} [mergeBoolValue] Represents a boolean value.
     * @param {object} [mergeStructValue] Represents a structured value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleMetadata(
      id?: string,
      key?: string,
      mergeNullValue?: 'NULL_VALUE',
      mergeNumberValue?: number,
      mergeStringValue?: string,
      mergeBoolValue?: boolean,
      mergeStructValue?: object,
      options?: any
    ): AxiosPromise<ApiRoleMetadataResponse> {
      return RolesApiFp(configuration)
        .roleMetadata(
          id,
          key,
          mergeNullValue,
          mergeNumberValue,
          mergeStringValue,
          mergeBoolValue,
          mergeStructValue,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'contacts' | 'cc_list' | 'cc_bucket' | 'calendars' | 'devices' | 'cc_agent' | 'cc_team' | 'cc_resource' | 'cc_resource_group' | 'cc_queue' | 'roles' | 'users' | 'cognitive_profile'} object bool admin &#x3D; 4;  // filter: where CURRENT user is \&#39;ADMIN\&#39; of REQUIRED !
     * @param {string} recordId identifier
     * @param {Array<string>} [ids] ----- Role-specific Filters ----------------- //  filter: .id &#x3D; any(:ids...)
     * @param {string} [name] filter: group name like
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [q] filter: term of search (name, description)
     * @param {string} [recordName] display name
     * @param {Array<string>} [fields] controls  output
     * @param {Array<string>} [sort] sort: \&quot;field\&quot; asc; \&quot;!field\&quot; desc
     * @param {number} [page] page number
     * @param {number} [size] page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRecordAvailableRoles(
      object:
        | 'contacts'
        | 'cc_list'
        | 'cc_bucket'
        | 'calendars'
        | 'devices'
        | 'cc_agent'
        | 'cc_team'
        | 'cc_resource'
        | 'cc_resource_group'
        | 'cc_queue'
        | 'roles'
        | 'users'
        | 'cognitive_profile',
      recordId: string,
      ids?: Array<string>,
      name?: string,
      userId?: string,
      userName?: string,
      q?: string,
      recordName?: string,
      fields?: Array<string>,
      sort?: Array<string>,
      page?: number,
      size?: number,
      options?: any
    ): AxiosPromise<ApiSearchRolesResponse> {
      return RolesApiFp(configuration)
        .searchRecordAvailableRoles(
          object,
          recordId,
          ids,
          name,
          userId,
          userName,
          q,
          recordName,
          fields,
          sort,
          page,
          size,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {Array<string>} [ids] ----- Role-specific Filters ----------------- //  filter: .id &#x3D; any(:ids...)
     * @param {string} [name] filter: group name like
     * @param {string} [userId] Object ID
     * @param {string} [userName] Display Name
     * @param {string} [q] filter: term of search (name, description)
     * @param {Array<string>} [fields] bool admin &#x3D; 4;  // filter: where CURRENT user is \&#39;ADMIN\&#39; of controls  output
     * @param {Array<string>} [sort] sort: \&quot;field\&quot; asc; \&quot;!field\&quot; desc
     * @param {number} [page] page number
     * @param {number} [size] page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRoles(
      ids?: Array<string>,
      name?: string,
      userId?: string,
      userName?: string,
      q?: string,
      fields?: Array<string>,
      sort?: Array<string>,
      page?: number,
      size?: number,
      options?: any
    ): AxiosPromise<ApiSearchRolesResponse> {
      return RolesApiFp(configuration)
        .searchRoles(
          ids,
          name,
          userId,
          userName,
          q,
          fields,
          sort,
          page,
          size,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} roleId oid
     * @param {ApiRolesUpdateRoleBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(
      roleId: string,
      body: ApiRolesUpdateRoleBody,
      options?: any
    ): AxiosPromise<ApiUpdateRoleResponse> {
      return RolesApiFp(configuration)
        .updateRole(roleId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} roleId oid
     * @param {ApiRolesUpdateRoleBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole2(
      roleId: string,
      body: ApiRolesUpdateRoleBody,
      options?: any
    ): AxiosPromise<ApiUpdateRoleResponse> {
      return RolesApiFp(configuration)
        .updateRole2(roleId, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
  /**
   *
   * @param {ApiCreateRoleRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public createRole(body: ApiCreateRoleRequest, options?: any) {
    return RolesApiFp(this.configuration)
      .createRole(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id DELETE /roles/{id}
   * @param {Array<string>} [ids] POST /roles/delete {\&quot;ids\&quot;}
   * @param {boolean} [permanent] deleteOrMark \&#39;deleted\&#39; ?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public deleteRole(
    id: string,
    ids?: Array<string>,
    permanent?: boolean,
    options?: any
  ) {
    return RolesApiFp(this.configuration)
      .deleteRole(id, ids, permanent, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id role.id
   * @param {Array<string>} [fields] select projection  select: output (fields,...)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public readRole(id: string, fields?: Array<string>, options?: any) {
    return RolesApiFp(this.configuration)
      .readRole(id, fields, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} [id] Optional. Unique ID of metadata role owner
   * @param {string} [key] Optional. Partial metadata document key name
   * @param {'NULL_VALUE'} [mergeNullValue] Represents a null value.   - NULL_VALUE: Null value.
   * @param {number} [mergeNumberValue] Represents a double value.
   * @param {string} [mergeStringValue] Represents a string value.
   * @param {boolean} [mergeBoolValue] Represents a boolean value.
   * @param {object} [mergeStructValue] Represents a structured value.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public roleMetadata(
    id?: string,
    key?: string,
    mergeNullValue?: 'NULL_VALUE',
    mergeNumberValue?: number,
    mergeStringValue?: string,
    mergeBoolValue?: boolean,
    mergeStructValue?: object,
    options?: any
  ) {
    return RolesApiFp(this.configuration)
      .roleMetadata(
        id,
        key,
        mergeNullValue,
        mergeNumberValue,
        mergeStringValue,
        mergeBoolValue,
        mergeStructValue,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'contacts' | 'cc_list' | 'cc_bucket' | 'calendars' | 'devices' | 'cc_agent' | 'cc_team' | 'cc_resource' | 'cc_resource_group' | 'cc_queue' | 'roles' | 'users' | 'cognitive_profile'} object bool admin &#x3D; 4;  // filter: where CURRENT user is \&#39;ADMIN\&#39; of REQUIRED !
   * @param {string} recordId identifier
   * @param {Array<string>} [ids] ----- Role-specific Filters ----------------- //  filter: .id &#x3D; any(:ids...)
   * @param {string} [name] filter: group name like
   * @param {string} [userId] Object ID
   * @param {string} [userName] Display Name
   * @param {string} [q] filter: term of search (name, description)
   * @param {string} [recordName] display name
   * @param {Array<string>} [fields] controls  output
   * @param {Array<string>} [sort] sort: \&quot;field\&quot; asc; \&quot;!field\&quot; desc
   * @param {number} [page] page number
   * @param {number} [size] page size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public searchRecordAvailableRoles(
    object:
      | 'contacts'
      | 'cc_list'
      | 'cc_bucket'
      | 'calendars'
      | 'devices'
      | 'cc_agent'
      | 'cc_team'
      | 'cc_resource'
      | 'cc_resource_group'
      | 'cc_queue'
      | 'roles'
      | 'users'
      | 'cognitive_profile',
    recordId: string,
    ids?: Array<string>,
    name?: string,
    userId?: string,
    userName?: string,
    q?: string,
    recordName?: string,
    fields?: Array<string>,
    sort?: Array<string>,
    page?: number,
    size?: number,
    options?: any
  ) {
    return RolesApiFp(this.configuration)
      .searchRecordAvailableRoles(
        object,
        recordId,
        ids,
        name,
        userId,
        userName,
        q,
        recordName,
        fields,
        sort,
        page,
        size,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {Array<string>} [ids] ----- Role-specific Filters ----------------- //  filter: .id &#x3D; any(:ids...)
   * @param {string} [name] filter: group name like
   * @param {string} [userId] Object ID
   * @param {string} [userName] Display Name
   * @param {string} [q] filter: term of search (name, description)
   * @param {Array<string>} [fields] bool admin &#x3D; 4;  // filter: where CURRENT user is \&#39;ADMIN\&#39; of controls  output
   * @param {Array<string>} [sort] sort: \&quot;field\&quot; asc; \&quot;!field\&quot; desc
   * @param {number} [page] page number
   * @param {number} [size] page size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public searchRoles(
    ids?: Array<string>,
    name?: string,
    userId?: string,
    userName?: string,
    q?: string,
    fields?: Array<string>,
    sort?: Array<string>,
    page?: number,
    size?: number,
    options?: any
  ) {
    return RolesApiFp(this.configuration)
      .searchRoles(
        ids,
        name,
        userId,
        userName,
        q,
        fields,
        sort,
        page,
        size,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} roleId oid
   * @param {ApiRolesUpdateRoleBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public updateRole(
    roleId: string,
    body: ApiRolesUpdateRoleBody,
    options?: any
  ) {
    return RolesApiFp(this.configuration)
      .updateRole(roleId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} roleId oid
   * @param {ApiRolesUpdateRoleBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public updateRole2(
    roleId: string,
    body: ApiRolesUpdateRoleBody,
    options?: any
  ) {
    return RolesApiFp(this.configuration)
      .updateRole2(roleId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
