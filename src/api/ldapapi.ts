// tslint:disable
/**
 * Webitel API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 24.04.0
 * Contact: support@webitel.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
import { Configuration } from '../configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base'
// @ts-ignore
import { ApiDeleteLDAPRequest } from '../api'
// @ts-ignore
import { ApiLDAPCatalog } from '../api'
// @ts-ignore
import { ApiLDAPCreateLDAPTemplateBody } from '../api'
// @ts-ignore
import { ApiLDAPDeleteLDAPTemplateBody } from '../api'
// @ts-ignore
import { ApiLDAPLDAPSearchBody } from '../api'
// @ts-ignore
import { ApiLDAPResyncLDAPCatalogBody } from '../api'
// @ts-ignore
import { ApiLDAPSearchRequest } from '../api'
// @ts-ignore
import { ApiLDAPSearchResponse } from '../api'
// @ts-ignore
import { ApiLDAPTemplate } from '../api'
// @ts-ignore
import { ApiLDAPTemplateResponse } from '../api'
// @ts-ignore
import { ApiLDAPUpdateLDAPCatalogBody } from '../api'
// @ts-ignore
import { ApiLDAPUpdateLDAPTemplateBody } from '../api'
// @ts-ignore
import { ApiLDAProcess } from '../api'
// @ts-ignore
import { ApiLDAProcessResponse } from '../api'
// @ts-ignore
import { ApiSearchLDAPResponse } from '../api'
/**
 * LDAPApi - axios parameter creator
 * @export
 */
export const LDAPApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create LDAP profile
     * @param {ApiLDAPCatalog} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLDAPCatalog: async (
      body: ApiLDAPCatalog,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createLDAPCatalog.'
        )
      }
      const localVarPath = `/ldap`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} catalogId identifier
     * @param {ApiLDAPCreateLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLDAPTemplate: async (
      catalogId: string,
      body: ApiLDAPCreateLDAPTemplateBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling createLDAPTemplate.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createLDAPTemplate.'
        )
      }
      const localVarPath = `/ldap/{catalog.id}/templates`.replace(
        `{${'catalog.id'}}`,
        encodeURIComponent(String(catalogId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete LDAP profile(s) ...
     * @param {string} id catalog id
     * @param {boolean} [relatedObjects] WITH objects bound to ?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLDAPCatalog: async (
      id: string,
      relatedObjects?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteLDAPCatalog.'
        )
      }
      const localVarPath = `/ldap/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (relatedObjects !== undefined) {
        localVarQueryParameter['related_objects'] = relatedObjects
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete LDAP profile(s) ...
     * @param {ApiDeleteLDAPRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLDAPCatalog2: async (
      body: ApiDeleteLDAPRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling deleteLDAPCatalog2.'
        )
      }
      const localVarPath = `/ldap`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
     * @param {ApiLDAPDeleteLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLDAPTemplate: async (
      catalogId: string,
      id: Array<string>,
      body: ApiLDAPDeleteLDAPTemplateBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling deleteLDAPTemplate.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteLDAPTemplate.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling deleteLDAPTemplate.'
        )
      }
      const localVarPath = `/ldap/{catalog_id}/templates/{id}`
        .replace(`{${'catalog_id'}}`, encodeURIComponent(String(catalogId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {ApiLDAPDeleteLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLDAPTemplate2: async (
      catalogId: string,
      body: ApiLDAPDeleteLDAPTemplateBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling deleteLDAPTemplate2.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling deleteLDAPTemplate2.'
        )
      }
      const localVarPath = `/ldap/{catalog_id}/templates`.replace(
        `{${'catalog_id'}}`,
        encodeURIComponent(String(catalogId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {string} catalogId ----- connection ----- Optional. ID of the preconfigured LDAP catalog
     * @param {ApiLDAPLDAPSearchBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lDAPSearch: async (
      catalogId: string,
      body: ApiLDAPLDAPSearchBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling lDAPSearch.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling lDAPSearch.'
        )
      }
      const localVarPath = `/ldap/{catalog_id}/search`.replace(
        `{${'catalog_id'}}`,
        encodeURIComponent(String(catalogId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {string} catalogId ----- connection ----- Optional. ID of the preconfigured LDAP catalog
     * @param {string} [url] Optional. URL to establish connection to LDAP catalog  URL e.g.: [(ldap|ldapi|ldaps)://]host[:port]
     * @param {string} [tlsPEM] TODO: (!)  base64
     * @param {string} [bind] ----- BIND: Authorization -----  authorization method e.g.: SIMPLE, SAML, NTLM, etc.
     * @param {string} [username] bind_dn
     * @param {string} [password] password
     * @param {string} [baseObject] ----- SearchRequest ----- baseObject [D]istinguished[N]ame
     * @param {number} [scope] baseObject              (0), singleLevel             (1), wholeSubtree            (2)
     * @param {number} [derefAliases] neverDerefAliases       (0), derefInSearching        (1), derefFindingBaseObj     (2), derefAlways             (3)
     * @param {string} [sizeLimit] INTEGER (0 ..  maxInt),
     * @param {string} [timeLimit] INTEGER (0 ..  maxInt),
     * @param {boolean} [typesOnly] BOOLEAN,
     * @param {string} [filter] Filter,
     * @param {Array<string>} [attributes] AttributeSelection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lDAPSearch2: async (
      catalogId: string,
      url?: string,
      tlsPEM?: string,
      bind?: string,
      username?: string,
      password?: string,
      baseObject?: string,
      scope?: number,
      derefAliases?: number,
      sizeLimit?: string,
      timeLimit?: string,
      typesOnly?: boolean,
      filter?: string,
      attributes?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling lDAPSearch2.'
        )
      }
      const localVarPath = `/ldap/{catalog_id}/search`.replace(
        `{${'catalog_id'}}`,
        encodeURIComponent(String(catalogId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (url !== undefined) {
        localVarQueryParameter['url'] = url
      }

      if (tlsPEM !== undefined) {
        localVarQueryParameter['tls.PEM'] = tlsPEM
      }

      if (bind !== undefined) {
        localVarQueryParameter['bind'] = bind
      }

      if (username !== undefined) {
        localVarQueryParameter['username'] = username
      }

      if (password !== undefined) {
        localVarQueryParameter['password'] = password
      }

      if (baseObject !== undefined) {
        localVarQueryParameter['baseObject'] = baseObject
      }

      if (scope !== undefined) {
        localVarQueryParameter['scope'] = scope
      }

      if (derefAliases !== undefined) {
        localVarQueryParameter['derefAliases'] = derefAliases
      }

      if (sizeLimit !== undefined) {
        localVarQueryParameter['sizeLimit'] = sizeLimit
      }

      if (timeLimit !== undefined) {
        localVarQueryParameter['timeLimit'] = timeLimit
      }

      if (typesOnly !== undefined) {
        localVarQueryParameter['typesOnly'] = typesOnly
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (attributes) {
        localVarQueryParameter['attributes'] = attributes
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {ApiLDAPSearchRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lDAPSearch3: async (
      body: ApiLDAPSearchRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling lDAPSearch3.'
        )
      }
      const localVarPath = `/ldap/search`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {string} [catalogId] ----- connection ----- Optional. ID of the preconfigured LDAP catalog
     * @param {string} [url] Optional. URL to establish connection to LDAP catalog  URL e.g.: [(ldap|ldapi|ldaps)://]host[:port]
     * @param {string} [tlsPEM] TODO: (!)  base64
     * @param {string} [bind] ----- BIND: Authorization -----  authorization method e.g.: SIMPLE, SAML, NTLM, etc.
     * @param {string} [username] bind_dn
     * @param {string} [password] password
     * @param {string} [baseObject] ----- SearchRequest ----- baseObject [D]istinguished[N]ame
     * @param {number} [scope] baseObject              (0), singleLevel             (1), wholeSubtree            (2)
     * @param {number} [derefAliases] neverDerefAliases       (0), derefInSearching        (1), derefFindingBaseObj     (2), derefAlways             (3)
     * @param {string} [sizeLimit] INTEGER (0 ..  maxInt),
     * @param {string} [timeLimit] INTEGER (0 ..  maxInt),
     * @param {boolean} [typesOnly] BOOLEAN,
     * @param {string} [filter] Filter,
     * @param {Array<string>} [attributes] AttributeSelection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lDAPSearch4: async (
      catalogId?: string,
      url?: string,
      tlsPEM?: string,
      bind?: string,
      username?: string,
      password?: string,
      baseObject?: string,
      scope?: number,
      derefAliases?: number,
      sizeLimit?: string,
      timeLimit?: string,
      typesOnly?: boolean,
      filter?: string,
      attributes?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/ldap/search`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (catalogId !== undefined) {
        localVarQueryParameter['catalog_id'] = catalogId
      }

      if (url !== undefined) {
        localVarQueryParameter['url'] = url
      }

      if (tlsPEM !== undefined) {
        localVarQueryParameter['tls.PEM'] = tlsPEM
      }

      if (bind !== undefined) {
        localVarQueryParameter['bind'] = bind
      }

      if (username !== undefined) {
        localVarQueryParameter['username'] = username
      }

      if (password !== undefined) {
        localVarQueryParameter['password'] = password
      }

      if (baseObject !== undefined) {
        localVarQueryParameter['baseObject'] = baseObject
      }

      if (scope !== undefined) {
        localVarQueryParameter['scope'] = scope
      }

      if (derefAliases !== undefined) {
        localVarQueryParameter['derefAliases'] = derefAliases
      }

      if (sizeLimit !== undefined) {
        localVarQueryParameter['sizeLimit'] = sizeLimit
      }

      if (timeLimit !== undefined) {
        localVarQueryParameter['timeLimit'] = timeLimit
      }

      if (typesOnly !== undefined) {
        localVarQueryParameter['typesOnly'] = typesOnly
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (attributes) {
        localVarQueryParameter['attributes'] = attributes
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Read LDAP catalog profile by .id
     * @param {Array<string>} id ----- Search Basic Filters ---------------------------  selection: by unique identifier
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {string} [q] term-of-search: lookup[name]
     * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
     * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    locateLDAPCatalog: async (
      id: Array<string>,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      q?: string,
      name?: string,
      access?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling locateLDAPCatalog.'
        )
      }
      const localVarPath = `/ldap/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (access !== undefined) {
        localVarQueryParameter['access'] = access
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [name]
     * @param {string} [baseDn]
     * @param {string} [objclass]
     * @param {boolean} [enabled]
     * @param {boolean} [disabled]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    locateLDAPTemplate: async (
      catalogId: string,
      id: Array<string>,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      q?: string,
      name?: string,
      baseDn?: string,
      objclass?: string,
      enabled?: boolean,
      disabled?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling locateLDAPTemplate.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling locateLDAPTemplate.'
        )
      }
      const localVarPath = `/ldap/{catalog_id}/templates/{id}`
        .replace(`{${'catalog_id'}}`, encodeURIComponent(String(catalogId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (baseDn !== undefined) {
        localVarQueryParameter['base_dn'] = baseDn
      }

      if (objclass !== undefined) {
        localVarQueryParameter['objclass'] = objclass
      }

      if (enabled !== undefined) {
        localVarQueryParameter['enabled'] = enabled
      }

      if (disabled !== undefined) {
        localVarQueryParameter['disabled'] = disabled
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary (ResyncLDAPResponse) {
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search process by unique .id
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [template]
     * @param {Array<string>} [objclass]
     * @param {boolean} [failed] WITH .errs
     * @param {boolean} [enabled] created|updated
     * @param {boolean} [disabled] deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    locateLDAProcess: async (
      catalogId: string,
      id: Array<string>,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      q?: string,
      template?: string,
      objclass?: Array<string>,
      failed?: boolean,
      enabled?: boolean,
      disabled?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling locateLDAProcess.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling locateLDAProcess.'
        )
      }
      const localVarPath = `/ldap/{catalog_id}/rsync/{id}`
        .replace(`{${'catalog_id'}}`, encodeURIComponent(String(catalogId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (template !== undefined) {
        localVarQueryParameter['template'] = template
      }

      if (objclass) {
        localVarQueryParameter['objclass'] = objclass
      }

      if (failed !== undefined) {
        localVarQueryParameter['failed'] = failed
      }

      if (enabled !== undefined) {
        localVarQueryParameter['enabled'] = enabled
      }

      if (disabled !== undefined) {
        localVarQueryParameter['disabled'] = disabled
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * (ResyncLDAPResponse) {
     * @summary Resync LDAP directory catalog changes ...
     * @param {string} catalogId LDAP Catalog unique IDentifier to sync with  catalog_id
     * @param {ApiLDAPResyncLDAPCatalogBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resyncLDAPCatalog: async (
      catalogId: string,
      body: ApiLDAPResyncLDAPCatalogBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling resyncLDAPCatalog.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling resyncLDAPCatalog.'
        )
      }
      const localVarPath = `/ldap/{catalog_id}/rsync`.replace(
        `{${'catalog_id'}}`,
        encodeURIComponent(String(catalogId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Search for LDAP directories ...
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [id] ----- Search Basic Filters ---------------------------  selection: by unique identifier
     * @param {string} [q] term-of-search: lookup[name]
     * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
     * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchLDAPCatalog: async (
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      id?: Array<string>,
      q?: string,
      name?: string,
      access?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/ldap`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (access !== undefined) {
        localVarQueryParameter['access'] = access
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [id] ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [name]
     * @param {string} [baseDn]
     * @param {string} [objclass]
     * @param {boolean} [enabled]
     * @param {boolean} [disabled]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchLDAPTemplate: async (
      catalogId: string,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      id?: Array<string>,
      q?: string,
      name?: string,
      baseDn?: string,
      objclass?: string,
      enabled?: boolean,
      disabled?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling searchLDAPTemplate.'
        )
      }
      const localVarPath = `/ldap/{catalog_id}/templates`.replace(
        `{${'catalog_id'}}`,
        encodeURIComponent(String(catalogId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (baseDn !== undefined) {
        localVarQueryParameter['base_dn'] = baseDn
      }

      if (objclass !== undefined) {
        localVarQueryParameter['objclass'] = objclass
      }

      if (enabled !== undefined) {
        localVarQueryParameter['enabled'] = enabled
      }

      if (disabled !== undefined) {
        localVarQueryParameter['disabled'] = disabled
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary (ResyncLDAPResponse) {
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [id] ----- Search Basic Filters --------------------------- OPTIONAL. Search process by unique .id
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [template]
     * @param {Array<string>} [objclass]
     * @param {boolean} [failed] WITH .errs
     * @param {boolean} [enabled] created|updated
     * @param {boolean} [disabled] deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchLDAProcess: async (
      catalogId: string,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      id?: Array<string>,
      q?: string,
      template?: string,
      objclass?: Array<string>,
      failed?: boolean,
      enabled?: boolean,
      disabled?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling searchLDAProcess.'
        )
      }
      const localVarPath = `/ldap/{catalog_id}/rsync`.replace(
        `{${'catalog_id'}}`,
        encodeURIComponent(String(catalogId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (template !== undefined) {
        localVarQueryParameter['template'] = template
      }

      if (objclass) {
        localVarQueryParameter['objclass'] = objclass
      }

      if (failed !== undefined) {
        localVarQueryParameter['failed'] = failed
      }

      if (enabled !== undefined) {
        localVarQueryParameter['enabled'] = enabled
      }

      if (disabled !== undefined) {
        localVarQueryParameter['disabled'] = disabled
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update LDAP profile details
     * @param {string} catalogId identity int64 dc &#x3D; 1;
     * @param {ApiLDAPUpdateLDAPCatalogBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLDAPCatalog: async (
      catalogId: string,
      body: ApiLDAPUpdateLDAPCatalogBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling updateLDAPCatalog.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateLDAPCatalog.'
        )
      }
      const localVarPath = `/ldap/{catalog.id}`.replace(
        `{${'catalog.id'}}`,
        encodeURIComponent(String(catalogId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update LDAP profile details
     * @param {string} catalogId identity int64 dc &#x3D; 1;
     * @param {ApiLDAPUpdateLDAPCatalogBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLDAPCatalog2: async (
      catalogId: string,
      body: ApiLDAPUpdateLDAPCatalogBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'catalogId' is not null or undefined
      if (catalogId === null || catalogId === undefined) {
        throw new RequiredError(
          'catalogId',
          'Required parameter catalogId was null or undefined when calling updateLDAPCatalog2.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateLDAPCatalog2.'
        )
      }
      const localVarPath = `/ldap/{catalog.id}`.replace(
        `{${'catalog.id'}}`,
        encodeURIComponent(String(catalogId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} templateCatalogId identifier
     * @param {string} templateId ID unique
     * @param {ApiLDAPUpdateLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLDAPTemplate: async (
      templateCatalogId: string,
      templateId: string,
      body: ApiLDAPUpdateLDAPTemplateBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'templateCatalogId' is not null or undefined
      if (templateCatalogId === null || templateCatalogId === undefined) {
        throw new RequiredError(
          'templateCatalogId',
          'Required parameter templateCatalogId was null or undefined when calling updateLDAPTemplate.'
        )
      }
      // verify required parameter 'templateId' is not null or undefined
      if (templateId === null || templateId === undefined) {
        throw new RequiredError(
          'templateId',
          'Required parameter templateId was null or undefined when calling updateLDAPTemplate.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateLDAPTemplate.'
        )
      }
      const localVarPath = `/ldap/{template.catalog.id}/templates/{template.id}`
        .replace(
          `{${'template.catalog.id'}}`,
          encodeURIComponent(String(templateCatalogId))
        )
        .replace(`{${'template.id'}}`, encodeURIComponent(String(templateId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} templateCatalogId identifier
     * @param {string} templateId ID unique
     * @param {ApiLDAPUpdateLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLDAPTemplate2: async (
      templateCatalogId: string,
      templateId: string,
      body: ApiLDAPUpdateLDAPTemplateBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'templateCatalogId' is not null or undefined
      if (templateCatalogId === null || templateCatalogId === undefined) {
        throw new RequiredError(
          'templateCatalogId',
          'Required parameter templateCatalogId was null or undefined when calling updateLDAPTemplate2.'
        )
      }
      // verify required parameter 'templateId' is not null or undefined
      if (templateId === null || templateId === undefined) {
        throw new RequiredError(
          'templateId',
          'Required parameter templateId was null or undefined when calling updateLDAPTemplate2.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateLDAPTemplate2.'
        )
      }
      const localVarPath = `/ldap/{template.catalog.id}/templates/{template.id}`
        .replace(
          `{${'template.catalog.id'}}`,
          encodeURIComponent(String(templateCatalogId))
        )
        .replace(`{${'template.id'}}`, encodeURIComponent(String(templateId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * LDAPApi - functional programming interface
 * @export
 */
export const LDAPApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create LDAP profile
     * @param {ApiLDAPCatalog} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLDAPCatalog(
      body: ApiLDAPCatalog,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiLDAPCatalog>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).createLDAPCatalog(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} catalogId identifier
     * @param {ApiLDAPCreateLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLDAPTemplate(
      catalogId: string,
      body: ApiLDAPCreateLDAPTemplateBody,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAPTemplate>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).createLDAPTemplate(catalogId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete LDAP profile(s) ...
     * @param {string} id catalog id
     * @param {boolean} [relatedObjects] WITH objects bound to ?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLDAPCatalog(
      id: string,
      relatedObjects?: boolean,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiLDAPCatalog>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).deleteLDAPCatalog(id, relatedObjects, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete LDAP profile(s) ...
     * @param {ApiDeleteLDAPRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLDAPCatalog2(
      body: ApiDeleteLDAPRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiLDAPCatalog>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).deleteLDAPCatalog2(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
     * @param {ApiLDAPDeleteLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLDAPTemplate(
      catalogId: string,
      id: Array<string>,
      body: ApiLDAPDeleteLDAPTemplateBody,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAPTemplateResponse>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).deleteLDAPTemplate(catalogId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {ApiLDAPDeleteLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLDAPTemplate2(
      catalogId: string,
      body: ApiLDAPDeleteLDAPTemplateBody,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAPTemplateResponse>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).deleteLDAPTemplate2(catalogId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {string} catalogId ----- connection ----- Optional. ID of the preconfigured LDAP catalog
     * @param {ApiLDAPLDAPSearchBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lDAPSearch(
      catalogId: string,
      body: ApiLDAPLDAPSearchBody,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAPSearchResponse>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).lDAPSearch(catalogId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {string} catalogId ----- connection ----- Optional. ID of the preconfigured LDAP catalog
     * @param {string} [url] Optional. URL to establish connection to LDAP catalog  URL e.g.: [(ldap|ldapi|ldaps)://]host[:port]
     * @param {string} [tlsPEM] TODO: (!)  base64
     * @param {string} [bind] ----- BIND: Authorization -----  authorization method e.g.: SIMPLE, SAML, NTLM, etc.
     * @param {string} [username] bind_dn
     * @param {string} [password] password
     * @param {string} [baseObject] ----- SearchRequest ----- baseObject [D]istinguished[N]ame
     * @param {number} [scope] baseObject              (0), singleLevel             (1), wholeSubtree            (2)
     * @param {number} [derefAliases] neverDerefAliases       (0), derefInSearching        (1), derefFindingBaseObj     (2), derefAlways             (3)
     * @param {string} [sizeLimit] INTEGER (0 ..  maxInt),
     * @param {string} [timeLimit] INTEGER (0 ..  maxInt),
     * @param {boolean} [typesOnly] BOOLEAN,
     * @param {string} [filter] Filter,
     * @param {Array<string>} [attributes] AttributeSelection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lDAPSearch2(
      catalogId: string,
      url?: string,
      tlsPEM?: string,
      bind?: string,
      username?: string,
      password?: string,
      baseObject?: string,
      scope?: number,
      derefAliases?: number,
      sizeLimit?: string,
      timeLimit?: string,
      typesOnly?: boolean,
      filter?: string,
      attributes?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAPSearchResponse>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).lDAPSearch2(
        catalogId,
        url,
        tlsPEM,
        bind,
        username,
        password,
        baseObject,
        scope,
        derefAliases,
        sizeLimit,
        timeLimit,
        typesOnly,
        filter,
        attributes,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {ApiLDAPSearchRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lDAPSearch3(
      body: ApiLDAPSearchRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAPSearchResponse>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).lDAPSearch3(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {string} [catalogId] ----- connection ----- Optional. ID of the preconfigured LDAP catalog
     * @param {string} [url] Optional. URL to establish connection to LDAP catalog  URL e.g.: [(ldap|ldapi|ldaps)://]host[:port]
     * @param {string} [tlsPEM] TODO: (!)  base64
     * @param {string} [bind] ----- BIND: Authorization -----  authorization method e.g.: SIMPLE, SAML, NTLM, etc.
     * @param {string} [username] bind_dn
     * @param {string} [password] password
     * @param {string} [baseObject] ----- SearchRequest ----- baseObject [D]istinguished[N]ame
     * @param {number} [scope] baseObject              (0), singleLevel             (1), wholeSubtree            (2)
     * @param {number} [derefAliases] neverDerefAliases       (0), derefInSearching        (1), derefFindingBaseObj     (2), derefAlways             (3)
     * @param {string} [sizeLimit] INTEGER (0 ..  maxInt),
     * @param {string} [timeLimit] INTEGER (0 ..  maxInt),
     * @param {boolean} [typesOnly] BOOLEAN,
     * @param {string} [filter] Filter,
     * @param {Array<string>} [attributes] AttributeSelection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lDAPSearch4(
      catalogId?: string,
      url?: string,
      tlsPEM?: string,
      bind?: string,
      username?: string,
      password?: string,
      baseObject?: string,
      scope?: number,
      derefAliases?: number,
      sizeLimit?: string,
      timeLimit?: string,
      typesOnly?: boolean,
      filter?: string,
      attributes?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAPSearchResponse>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).lDAPSearch4(
        catalogId,
        url,
        tlsPEM,
        bind,
        username,
        password,
        baseObject,
        scope,
        derefAliases,
        sizeLimit,
        timeLimit,
        typesOnly,
        filter,
        attributes,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Read LDAP catalog profile by .id
     * @param {Array<string>} id ----- Search Basic Filters ---------------------------  selection: by unique identifier
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {string} [q] term-of-search: lookup[name]
     * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
     * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async locateLDAPCatalog(
      id: Array<string>,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      q?: string,
      name?: string,
      access?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiLDAPCatalog>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).locateLDAPCatalog(
        id,
        page,
        size,
        fields,
        sort,
        q,
        name,
        access,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [name]
     * @param {string} [baseDn]
     * @param {string} [objclass]
     * @param {boolean} [enabled]
     * @param {boolean} [disabled]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async locateLDAPTemplate(
      catalogId: string,
      id: Array<string>,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      q?: string,
      name?: string,
      baseDn?: string,
      objclass?: string,
      enabled?: boolean,
      disabled?: boolean,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAPTemplate>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).locateLDAPTemplate(
        catalogId,
        id,
        page,
        size,
        fields,
        sort,
        q,
        name,
        baseDn,
        objclass,
        enabled,
        disabled,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary (ResyncLDAPResponse) {
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search process by unique .id
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [template]
     * @param {Array<string>} [objclass]
     * @param {boolean} [failed] WITH .errs
     * @param {boolean} [enabled] created|updated
     * @param {boolean} [disabled] deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async locateLDAProcess(
      catalogId: string,
      id: Array<string>,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      q?: string,
      template?: string,
      objclass?: Array<string>,
      failed?: boolean,
      enabled?: boolean,
      disabled?: boolean,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiLDAProcess>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).locateLDAProcess(
        catalogId,
        id,
        page,
        size,
        fields,
        sort,
        q,
        template,
        objclass,
        failed,
        enabled,
        disabled,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * (ResyncLDAPResponse) {
     * @summary Resync LDAP directory catalog changes ...
     * @param {string} catalogId LDAP Catalog unique IDentifier to sync with  catalog_id
     * @param {ApiLDAPResyncLDAPCatalogBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resyncLDAPCatalog(
      catalogId: string,
      body: ApiLDAPResyncLDAPCatalogBody,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiLDAProcess>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).resyncLDAPCatalog(catalogId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Search for LDAP directories ...
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [id] ----- Search Basic Filters ---------------------------  selection: by unique identifier
     * @param {string} [q] term-of-search: lookup[name]
     * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
     * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchLDAPCatalog(
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      id?: Array<string>,
      q?: string,
      name?: string,
      access?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiSearchLDAPResponse>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).searchLDAPCatalog(
        page,
        size,
        fields,
        sort,
        id,
        q,
        name,
        access,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [id] ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [name]
     * @param {string} [baseDn]
     * @param {string} [objclass]
     * @param {boolean} [enabled]
     * @param {boolean} [disabled]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchLDAPTemplate(
      catalogId: string,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      id?: Array<string>,
      q?: string,
      name?: string,
      baseDn?: string,
      objclass?: string,
      enabled?: boolean,
      disabled?: boolean,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAPTemplateResponse>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).searchLDAPTemplate(
        catalogId,
        page,
        size,
        fields,
        sort,
        id,
        q,
        name,
        baseDn,
        objclass,
        enabled,
        disabled,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary (ResyncLDAPResponse) {
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [id] ----- Search Basic Filters --------------------------- OPTIONAL. Search process by unique .id
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [template]
     * @param {Array<string>} [objclass]
     * @param {boolean} [failed] WITH .errs
     * @param {boolean} [enabled] created|updated
     * @param {boolean} [disabled] deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchLDAProcess(
      catalogId: string,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      id?: Array<string>,
      q?: string,
      template?: string,
      objclass?: Array<string>,
      failed?: boolean,
      enabled?: boolean,
      disabled?: boolean,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAProcessResponse>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).searchLDAProcess(
        catalogId,
        page,
        size,
        fields,
        sort,
        id,
        q,
        template,
        objclass,
        failed,
        enabled,
        disabled,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update LDAP profile details
     * @param {string} catalogId identity int64 dc &#x3D; 1;
     * @param {ApiLDAPUpdateLDAPCatalogBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLDAPCatalog(
      catalogId: string,
      body: ApiLDAPUpdateLDAPCatalogBody,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiLDAPCatalog>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).updateLDAPCatalog(catalogId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update LDAP profile details
     * @param {string} catalogId identity int64 dc &#x3D; 1;
     * @param {ApiLDAPUpdateLDAPCatalogBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLDAPCatalog2(
      catalogId: string,
      body: ApiLDAPUpdateLDAPCatalogBody,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiLDAPCatalog>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).updateLDAPCatalog2(catalogId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} templateCatalogId identifier
     * @param {string} templateId ID unique
     * @param {ApiLDAPUpdateLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLDAPTemplate(
      templateCatalogId: string,
      templateId: string,
      body: ApiLDAPUpdateLDAPTemplateBody,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAPTemplate>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).updateLDAPTemplate(templateCatalogId, templateId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} templateCatalogId identifier
     * @param {string} templateId ID unique
     * @param {ApiLDAPUpdateLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLDAPTemplate2(
      templateCatalogId: string,
      templateId: string,
      body: ApiLDAPUpdateLDAPTemplateBody,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApiLDAPTemplate>
    > {
      const localVarAxiosArgs = await LDAPApiAxiosParamCreator(
        configuration
      ).updateLDAPTemplate2(templateCatalogId, templateId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * LDAPApi - factory interface
 * @export
 */
export const LDAPApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create LDAP profile
     * @param {ApiLDAPCatalog} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLDAPCatalog(
      body: ApiLDAPCatalog,
      options?: any
    ): AxiosPromise<ApiLDAPCatalog> {
      return LDAPApiFp(configuration)
        .createLDAPCatalog(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} catalogId identifier
     * @param {ApiLDAPCreateLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLDAPTemplate(
      catalogId: string,
      body: ApiLDAPCreateLDAPTemplateBody,
      options?: any
    ): AxiosPromise<ApiLDAPTemplate> {
      return LDAPApiFp(configuration)
        .createLDAPTemplate(catalogId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete LDAP profile(s) ...
     * @param {string} id catalog id
     * @param {boolean} [relatedObjects] WITH objects bound to ?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLDAPCatalog(
      id: string,
      relatedObjects?: boolean,
      options?: any
    ): AxiosPromise<ApiLDAPCatalog> {
      return LDAPApiFp(configuration)
        .deleteLDAPCatalog(id, relatedObjects, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete LDAP profile(s) ...
     * @param {ApiDeleteLDAPRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLDAPCatalog2(
      body: ApiDeleteLDAPRequest,
      options?: any
    ): AxiosPromise<ApiLDAPCatalog> {
      return LDAPApiFp(configuration)
        .deleteLDAPCatalog2(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
     * @param {ApiLDAPDeleteLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLDAPTemplate(
      catalogId: string,
      id: Array<string>,
      body: ApiLDAPDeleteLDAPTemplateBody,
      options?: any
    ): AxiosPromise<ApiLDAPTemplateResponse> {
      return LDAPApiFp(configuration)
        .deleteLDAPTemplate(catalogId, id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {ApiLDAPDeleteLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLDAPTemplate2(
      catalogId: string,
      body: ApiLDAPDeleteLDAPTemplateBody,
      options?: any
    ): AxiosPromise<ApiLDAPTemplateResponse> {
      return LDAPApiFp(configuration)
        .deleteLDAPTemplate2(catalogId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {string} catalogId ----- connection ----- Optional. ID of the preconfigured LDAP catalog
     * @param {ApiLDAPLDAPSearchBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lDAPSearch(
      catalogId: string,
      body: ApiLDAPLDAPSearchBody,
      options?: any
    ): AxiosPromise<ApiLDAPSearchResponse> {
      return LDAPApiFp(configuration)
        .lDAPSearch(catalogId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {string} catalogId ----- connection ----- Optional. ID of the preconfigured LDAP catalog
     * @param {string} [url] Optional. URL to establish connection to LDAP catalog  URL e.g.: [(ldap|ldapi|ldaps)://]host[:port]
     * @param {string} [tlsPEM] TODO: (!)  base64
     * @param {string} [bind] ----- BIND: Authorization -----  authorization method e.g.: SIMPLE, SAML, NTLM, etc.
     * @param {string} [username] bind_dn
     * @param {string} [password] password
     * @param {string} [baseObject] ----- SearchRequest ----- baseObject [D]istinguished[N]ame
     * @param {number} [scope] baseObject              (0), singleLevel             (1), wholeSubtree            (2)
     * @param {number} [derefAliases] neverDerefAliases       (0), derefInSearching        (1), derefFindingBaseObj     (2), derefAlways             (3)
     * @param {string} [sizeLimit] INTEGER (0 ..  maxInt),
     * @param {string} [timeLimit] INTEGER (0 ..  maxInt),
     * @param {boolean} [typesOnly] BOOLEAN,
     * @param {string} [filter] Filter,
     * @param {Array<string>} [attributes] AttributeSelection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lDAPSearch2(
      catalogId: string,
      url?: string,
      tlsPEM?: string,
      bind?: string,
      username?: string,
      password?: string,
      baseObject?: string,
      scope?: number,
      derefAliases?: number,
      sizeLimit?: string,
      timeLimit?: string,
      typesOnly?: boolean,
      filter?: string,
      attributes?: Array<string>,
      options?: any
    ): AxiosPromise<ApiLDAPSearchResponse> {
      return LDAPApiFp(configuration)
        .lDAPSearch2(
          catalogId,
          url,
          tlsPEM,
          bind,
          username,
          password,
          baseObject,
          scope,
          derefAliases,
          sizeLimit,
          timeLimit,
          typesOnly,
          filter,
          attributes,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {ApiLDAPSearchRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lDAPSearch3(
      body: ApiLDAPSearchRequest,
      options?: any
    ): AxiosPromise<ApiLDAPSearchResponse> {
      return LDAPApiFp(configuration)
        .lDAPSearch3(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary LDAPSearch performs LDAP Search operation ...
     * @param {string} [catalogId] ----- connection ----- Optional. ID of the preconfigured LDAP catalog
     * @param {string} [url] Optional. URL to establish connection to LDAP catalog  URL e.g.: [(ldap|ldapi|ldaps)://]host[:port]
     * @param {string} [tlsPEM] TODO: (!)  base64
     * @param {string} [bind] ----- BIND: Authorization -----  authorization method e.g.: SIMPLE, SAML, NTLM, etc.
     * @param {string} [username] bind_dn
     * @param {string} [password] password
     * @param {string} [baseObject] ----- SearchRequest ----- baseObject [D]istinguished[N]ame
     * @param {number} [scope] baseObject              (0), singleLevel             (1), wholeSubtree            (2)
     * @param {number} [derefAliases] neverDerefAliases       (0), derefInSearching        (1), derefFindingBaseObj     (2), derefAlways             (3)
     * @param {string} [sizeLimit] INTEGER (0 ..  maxInt),
     * @param {string} [timeLimit] INTEGER (0 ..  maxInt),
     * @param {boolean} [typesOnly] BOOLEAN,
     * @param {string} [filter] Filter,
     * @param {Array<string>} [attributes] AttributeSelection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lDAPSearch4(
      catalogId?: string,
      url?: string,
      tlsPEM?: string,
      bind?: string,
      username?: string,
      password?: string,
      baseObject?: string,
      scope?: number,
      derefAliases?: number,
      sizeLimit?: string,
      timeLimit?: string,
      typesOnly?: boolean,
      filter?: string,
      attributes?: Array<string>,
      options?: any
    ): AxiosPromise<ApiLDAPSearchResponse> {
      return LDAPApiFp(configuration)
        .lDAPSearch4(
          catalogId,
          url,
          tlsPEM,
          bind,
          username,
          password,
          baseObject,
          scope,
          derefAliases,
          sizeLimit,
          timeLimit,
          typesOnly,
          filter,
          attributes,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Read LDAP catalog profile by .id
     * @param {Array<string>} id ----- Search Basic Filters ---------------------------  selection: by unique identifier
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {string} [q] term-of-search: lookup[name]
     * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
     * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    locateLDAPCatalog(
      id: Array<string>,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      q?: string,
      name?: string,
      access?: string,
      options?: any
    ): AxiosPromise<ApiLDAPCatalog> {
      return LDAPApiFp(configuration)
        .locateLDAPCatalog(
          id,
          page,
          size,
          fields,
          sort,
          q,
          name,
          access,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [name]
     * @param {string} [baseDn]
     * @param {string} [objclass]
     * @param {boolean} [enabled]
     * @param {boolean} [disabled]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    locateLDAPTemplate(
      catalogId: string,
      id: Array<string>,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      q?: string,
      name?: string,
      baseDn?: string,
      objclass?: string,
      enabled?: boolean,
      disabled?: boolean,
      options?: any
    ): AxiosPromise<ApiLDAPTemplate> {
      return LDAPApiFp(configuration)
        .locateLDAPTemplate(
          catalogId,
          id,
          page,
          size,
          fields,
          sort,
          q,
          name,
          baseDn,
          objclass,
          enabled,
          disabled,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary (ResyncLDAPResponse) {
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search process by unique .id
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [template]
     * @param {Array<string>} [objclass]
     * @param {boolean} [failed] WITH .errs
     * @param {boolean} [enabled] created|updated
     * @param {boolean} [disabled] deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    locateLDAProcess(
      catalogId: string,
      id: Array<string>,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      q?: string,
      template?: string,
      objclass?: Array<string>,
      failed?: boolean,
      enabled?: boolean,
      disabled?: boolean,
      options?: any
    ): AxiosPromise<ApiLDAProcess> {
      return LDAPApiFp(configuration)
        .locateLDAProcess(
          catalogId,
          id,
          page,
          size,
          fields,
          sort,
          q,
          template,
          objclass,
          failed,
          enabled,
          disabled,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * (ResyncLDAPResponse) {
     * @summary Resync LDAP directory catalog changes ...
     * @param {string} catalogId LDAP Catalog unique IDentifier to sync with  catalog_id
     * @param {ApiLDAPResyncLDAPCatalogBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resyncLDAPCatalog(
      catalogId: string,
      body: ApiLDAPResyncLDAPCatalogBody,
      options?: any
    ): AxiosPromise<ApiLDAProcess> {
      return LDAPApiFp(configuration)
        .resyncLDAPCatalog(catalogId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Search for LDAP directories ...
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [id] ----- Search Basic Filters ---------------------------  selection: by unique identifier
     * @param {string} [q] term-of-search: lookup[name]
     * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
     * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchLDAPCatalog(
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      id?: Array<string>,
      q?: string,
      name?: string,
      access?: string,
      options?: any
    ): AxiosPromise<ApiSearchLDAPResponse> {
      return LDAPApiFp(configuration)
        .searchLDAPCatalog(
          page,
          size,
          fields,
          sort,
          id,
          q,
          name,
          access,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [id] ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [name]
     * @param {string} [baseDn]
     * @param {string} [objclass]
     * @param {boolean} [enabled]
     * @param {boolean} [disabled]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchLDAPTemplate(
      catalogId: string,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      id?: Array<string>,
      q?: string,
      name?: string,
      baseDn?: string,
      objclass?: string,
      enabled?: boolean,
      disabled?: boolean,
      options?: any
    ): AxiosPromise<ApiLDAPTemplateResponse> {
      return LDAPApiFp(configuration)
        .searchLDAPTemplate(
          catalogId,
          page,
          size,
          fields,
          sort,
          id,
          q,
          name,
          baseDn,
          objclass,
          enabled,
          disabled,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary (ResyncLDAPResponse) {
     * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
     * @param {number} [page] ----- Select Options -------------------------  default: 1
     * @param {number} [size] default: 16
     * @param {Array<string>} [fields] attributes list
     * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
     * @param {Array<string>} [id] ----- Search Basic Filters --------------------------- OPTIONAL. Search process by unique .id
     * @param {string} [q] OPTIONAL. Filter(s) SET
     * @param {string} [template]
     * @param {Array<string>} [objclass]
     * @param {boolean} [failed] WITH .errs
     * @param {boolean} [enabled] created|updated
     * @param {boolean} [disabled] deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchLDAProcess(
      catalogId: string,
      page?: number,
      size?: number,
      fields?: Array<string>,
      sort?: Array<string>,
      id?: Array<string>,
      q?: string,
      template?: string,
      objclass?: Array<string>,
      failed?: boolean,
      enabled?: boolean,
      disabled?: boolean,
      options?: any
    ): AxiosPromise<ApiLDAProcessResponse> {
      return LDAPApiFp(configuration)
        .searchLDAProcess(
          catalogId,
          page,
          size,
          fields,
          sort,
          id,
          q,
          template,
          objclass,
          failed,
          enabled,
          disabled,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update LDAP profile details
     * @param {string} catalogId identity int64 dc &#x3D; 1;
     * @param {ApiLDAPUpdateLDAPCatalogBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLDAPCatalog(
      catalogId: string,
      body: ApiLDAPUpdateLDAPCatalogBody,
      options?: any
    ): AxiosPromise<ApiLDAPCatalog> {
      return LDAPApiFp(configuration)
        .updateLDAPCatalog(catalogId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update LDAP profile details
     * @param {string} catalogId identity int64 dc &#x3D; 1;
     * @param {ApiLDAPUpdateLDAPCatalogBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLDAPCatalog2(
      catalogId: string,
      body: ApiLDAPUpdateLDAPCatalogBody,
      options?: any
    ): AxiosPromise<ApiLDAPCatalog> {
      return LDAPApiFp(configuration)
        .updateLDAPCatalog2(catalogId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} templateCatalogId identifier
     * @param {string} templateId ID unique
     * @param {ApiLDAPUpdateLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLDAPTemplate(
      templateCatalogId: string,
      templateId: string,
      body: ApiLDAPUpdateLDAPTemplateBody,
      options?: any
    ): AxiosPromise<ApiLDAPTemplate> {
      return LDAPApiFp(configuration)
        .updateLDAPTemplate(templateCatalogId, templateId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} templateCatalogId identifier
     * @param {string} templateId ID unique
     * @param {ApiLDAPUpdateLDAPTemplateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLDAPTemplate2(
      templateCatalogId: string,
      templateId: string,
      body: ApiLDAPUpdateLDAPTemplateBody,
      options?: any
    ): AxiosPromise<ApiLDAPTemplate> {
      return LDAPApiFp(configuration)
        .updateLDAPTemplate2(templateCatalogId, templateId, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * LDAPApi - object-oriented interface
 * @export
 * @class LDAPApi
 * @extends {BaseAPI}
 */
export class LDAPApi extends BaseAPI {
  /**
   *
   * @summary Create LDAP profile
   * @param {ApiLDAPCatalog} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public createLDAPCatalog(body: ApiLDAPCatalog, options?: any) {
    return LDAPApiFp(this.configuration)
      .createLDAPCatalog(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} catalogId identifier
   * @param {ApiLDAPCreateLDAPTemplateBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public createLDAPTemplate(
    catalogId: string,
    body: ApiLDAPCreateLDAPTemplateBody,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .createLDAPTemplate(catalogId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete LDAP profile(s) ...
   * @param {string} id catalog id
   * @param {boolean} [relatedObjects] WITH objects bound to ?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public deleteLDAPCatalog(
    id: string,
    relatedObjects?: boolean,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .deleteLDAPCatalog(id, relatedObjects, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete LDAP profile(s) ...
   * @param {ApiDeleteLDAPRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public deleteLDAPCatalog2(body: ApiDeleteLDAPRequest, options?: any) {
    return LDAPApiFp(this.configuration)
      .deleteLDAPCatalog2(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
   * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
   * @param {ApiLDAPDeleteLDAPTemplateBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public deleteLDAPTemplate(
    catalogId: string,
    id: Array<string>,
    body: ApiLDAPDeleteLDAPTemplateBody,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .deleteLDAPTemplate(catalogId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
   * @param {ApiLDAPDeleteLDAPTemplateBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public deleteLDAPTemplate2(
    catalogId: string,
    body: ApiLDAPDeleteLDAPTemplateBody,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .deleteLDAPTemplate2(catalogId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary LDAPSearch performs LDAP Search operation ...
   * @param {string} catalogId ----- connection ----- Optional. ID of the preconfigured LDAP catalog
   * @param {ApiLDAPLDAPSearchBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public lDAPSearch(
    catalogId: string,
    body: ApiLDAPLDAPSearchBody,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .lDAPSearch(catalogId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary LDAPSearch performs LDAP Search operation ...
   * @param {string} catalogId ----- connection ----- Optional. ID of the preconfigured LDAP catalog
   * @param {string} [url] Optional. URL to establish connection to LDAP catalog  URL e.g.: [(ldap|ldapi|ldaps)://]host[:port]
   * @param {string} [tlsPEM] TODO: (!)  base64
   * @param {string} [bind] ----- BIND: Authorization -----  authorization method e.g.: SIMPLE, SAML, NTLM, etc.
   * @param {string} [username] bind_dn
   * @param {string} [password] password
   * @param {string} [baseObject] ----- SearchRequest ----- baseObject [D]istinguished[N]ame
   * @param {number} [scope] baseObject              (0), singleLevel             (1), wholeSubtree            (2)
   * @param {number} [derefAliases] neverDerefAliases       (0), derefInSearching        (1), derefFindingBaseObj     (2), derefAlways             (3)
   * @param {string} [sizeLimit] INTEGER (0 ..  maxInt),
   * @param {string} [timeLimit] INTEGER (0 ..  maxInt),
   * @param {boolean} [typesOnly] BOOLEAN,
   * @param {string} [filter] Filter,
   * @param {Array<string>} [attributes] AttributeSelection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public lDAPSearch2(
    catalogId: string,
    url?: string,
    tlsPEM?: string,
    bind?: string,
    username?: string,
    password?: string,
    baseObject?: string,
    scope?: number,
    derefAliases?: number,
    sizeLimit?: string,
    timeLimit?: string,
    typesOnly?: boolean,
    filter?: string,
    attributes?: Array<string>,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .lDAPSearch2(
        catalogId,
        url,
        tlsPEM,
        bind,
        username,
        password,
        baseObject,
        scope,
        derefAliases,
        sizeLimit,
        timeLimit,
        typesOnly,
        filter,
        attributes,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary LDAPSearch performs LDAP Search operation ...
   * @param {ApiLDAPSearchRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public lDAPSearch3(body: ApiLDAPSearchRequest, options?: any) {
    return LDAPApiFp(this.configuration)
      .lDAPSearch3(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary LDAPSearch performs LDAP Search operation ...
   * @param {string} [catalogId] ----- connection ----- Optional. ID of the preconfigured LDAP catalog
   * @param {string} [url] Optional. URL to establish connection to LDAP catalog  URL e.g.: [(ldap|ldapi|ldaps)://]host[:port]
   * @param {string} [tlsPEM] TODO: (!)  base64
   * @param {string} [bind] ----- BIND: Authorization -----  authorization method e.g.: SIMPLE, SAML, NTLM, etc.
   * @param {string} [username] bind_dn
   * @param {string} [password] password
   * @param {string} [baseObject] ----- SearchRequest ----- baseObject [D]istinguished[N]ame
   * @param {number} [scope] baseObject              (0), singleLevel             (1), wholeSubtree            (2)
   * @param {number} [derefAliases] neverDerefAliases       (0), derefInSearching        (1), derefFindingBaseObj     (2), derefAlways             (3)
   * @param {string} [sizeLimit] INTEGER (0 ..  maxInt),
   * @param {string} [timeLimit] INTEGER (0 ..  maxInt),
   * @param {boolean} [typesOnly] BOOLEAN,
   * @param {string} [filter] Filter,
   * @param {Array<string>} [attributes] AttributeSelection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public lDAPSearch4(
    catalogId?: string,
    url?: string,
    tlsPEM?: string,
    bind?: string,
    username?: string,
    password?: string,
    baseObject?: string,
    scope?: number,
    derefAliases?: number,
    sizeLimit?: string,
    timeLimit?: string,
    typesOnly?: boolean,
    filter?: string,
    attributes?: Array<string>,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .lDAPSearch4(
        catalogId,
        url,
        tlsPEM,
        bind,
        username,
        password,
        baseObject,
        scope,
        derefAliases,
        sizeLimit,
        timeLimit,
        typesOnly,
        filter,
        attributes,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Read LDAP catalog profile by .id
   * @param {Array<string>} id ----- Search Basic Filters ---------------------------  selection: by unique identifier
   * @param {number} [page] ----- Select Options -------------------------  default: 1
   * @param {number} [size] default: 16
   * @param {Array<string>} [fields] attributes list
   * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
   * @param {string} [q] term-of-search: lookup[name]
   * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
   * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public locateLDAPCatalog(
    id: Array<string>,
    page?: number,
    size?: number,
    fields?: Array<string>,
    sort?: Array<string>,
    q?: string,
    name?: string,
    access?: string,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .locateLDAPCatalog(id, page, size, fields, sort, q, name, access, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
   * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
   * @param {number} [page] ----- Select Options -------------------------  default: 1
   * @param {number} [size] default: 16
   * @param {Array<string>} [fields] attributes list
   * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
   * @param {string} [q] OPTIONAL. Filter(s) SET
   * @param {string} [name]
   * @param {string} [baseDn]
   * @param {string} [objclass]
   * @param {boolean} [enabled]
   * @param {boolean} [disabled]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public locateLDAPTemplate(
    catalogId: string,
    id: Array<string>,
    page?: number,
    size?: number,
    fields?: Array<string>,
    sort?: Array<string>,
    q?: string,
    name?: string,
    baseDn?: string,
    objclass?: string,
    enabled?: boolean,
    disabled?: boolean,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .locateLDAPTemplate(
        catalogId,
        id,
        page,
        size,
        fields,
        sort,
        q,
        name,
        baseDn,
        objclass,
        enabled,
        disabled,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary (ResyncLDAPResponse) {
   * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
   * @param {Array<string>} id ----- Search Basic Filters --------------------------- OPTIONAL. Search process by unique .id
   * @param {number} [page] ----- Select Options -------------------------  default: 1
   * @param {number} [size] default: 16
   * @param {Array<string>} [fields] attributes list
   * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
   * @param {string} [q] OPTIONAL. Filter(s) SET
   * @param {string} [template]
   * @param {Array<string>} [objclass]
   * @param {boolean} [failed] WITH .errs
   * @param {boolean} [enabled] created|updated
   * @param {boolean} [disabled] deleted
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public locateLDAProcess(
    catalogId: string,
    id: Array<string>,
    page?: number,
    size?: number,
    fields?: Array<string>,
    sort?: Array<string>,
    q?: string,
    template?: string,
    objclass?: Array<string>,
    failed?: boolean,
    enabled?: boolean,
    disabled?: boolean,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .locateLDAProcess(
        catalogId,
        id,
        page,
        size,
        fields,
        sort,
        q,
        template,
        objclass,
        failed,
        enabled,
        disabled,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * (ResyncLDAPResponse) {
   * @summary Resync LDAP directory catalog changes ...
   * @param {string} catalogId LDAP Catalog unique IDentifier to sync with  catalog_id
   * @param {ApiLDAPResyncLDAPCatalogBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public resyncLDAPCatalog(
    catalogId: string,
    body: ApiLDAPResyncLDAPCatalogBody,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .resyncLDAPCatalog(catalogId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Search for LDAP directories ...
   * @param {number} [page] ----- Select Options -------------------------  default: 1
   * @param {number} [size] default: 16
   * @param {Array<string>} [fields] attributes list
   * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
   * @param {Array<string>} [id] ----- Search Basic Filters ---------------------------  selection: by unique identifier
   * @param {string} [q] term-of-search: lookup[name]
   * @param {string} [name] case-ignore substring match: ILIKE \&#39;*\&#39; - any; \&#39;?\&#39; - one
   * @param {string} [access] [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public searchLDAPCatalog(
    page?: number,
    size?: number,
    fields?: Array<string>,
    sort?: Array<string>,
    id?: Array<string>,
    q?: string,
    name?: string,
    access?: string,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .searchLDAPCatalog(page, size, fields, sort, id, q, name, access, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
   * @param {number} [page] ----- Select Options -------------------------  default: 1
   * @param {number} [size] default: 16
   * @param {Array<string>} [fields] attributes list
   * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
   * @param {Array<string>} [id] ----- Search Basic Filters --------------------------- OPTIONAL. Search templates by .id
   * @param {string} [q] OPTIONAL. Filter(s) SET
   * @param {string} [name]
   * @param {string} [baseDn]
   * @param {string} [objclass]
   * @param {boolean} [enabled]
   * @param {boolean} [disabled]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public searchLDAPTemplate(
    catalogId: string,
    page?: number,
    size?: number,
    fields?: Array<string>,
    sort?: Array<string>,
    id?: Array<string>,
    q?: string,
    name?: string,
    baseDn?: string,
    objclass?: string,
    enabled?: boolean,
    disabled?: boolean,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .searchLDAPTemplate(
        catalogId,
        page,
        size,
        fields,
        sort,
        id,
        q,
        name,
        baseDn,
        objclass,
        enabled,
        disabled,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary (ResyncLDAPResponse) {
   * @param {string} catalogId REQUIRED. Parent LDAP catalog IDentifier
   * @param {number} [page] ----- Select Options -------------------------  default: 1
   * @param {number} [size] default: 16
   * @param {Array<string>} [fields] attributes list
   * @param {Array<string>} [sort] e.g.: \&quot;updated_at\&quot; - ASC; \&quot;!updated_at\&quot; - DESC;
   * @param {Array<string>} [id] ----- Search Basic Filters --------------------------- OPTIONAL. Search process by unique .id
   * @param {string} [q] OPTIONAL. Filter(s) SET
   * @param {string} [template]
   * @param {Array<string>} [objclass]
   * @param {boolean} [failed] WITH .errs
   * @param {boolean} [enabled] created|updated
   * @param {boolean} [disabled] deleted
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public searchLDAProcess(
    catalogId: string,
    page?: number,
    size?: number,
    fields?: Array<string>,
    sort?: Array<string>,
    id?: Array<string>,
    q?: string,
    template?: string,
    objclass?: Array<string>,
    failed?: boolean,
    enabled?: boolean,
    disabled?: boolean,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .searchLDAProcess(
        catalogId,
        page,
        size,
        fields,
        sort,
        id,
        q,
        template,
        objclass,
        failed,
        enabled,
        disabled,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update LDAP profile details
   * @param {string} catalogId identity int64 dc &#x3D; 1;
   * @param {ApiLDAPUpdateLDAPCatalogBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public updateLDAPCatalog(
    catalogId: string,
    body: ApiLDAPUpdateLDAPCatalogBody,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .updateLDAPCatalog(catalogId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update LDAP profile details
   * @param {string} catalogId identity int64 dc &#x3D; 1;
   * @param {ApiLDAPUpdateLDAPCatalogBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public updateLDAPCatalog2(
    catalogId: string,
    body: ApiLDAPUpdateLDAPCatalogBody,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .updateLDAPCatalog2(catalogId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} templateCatalogId identifier
   * @param {string} templateId ID unique
   * @param {ApiLDAPUpdateLDAPTemplateBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public updateLDAPTemplate(
    templateCatalogId: string,
    templateId: string,
    body: ApiLDAPUpdateLDAPTemplateBody,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .updateLDAPTemplate(templateCatalogId, templateId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} templateCatalogId identifier
   * @param {string} templateId ID unique
   * @param {ApiLDAPUpdateLDAPTemplateBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LDAPApi
   */
  public updateLDAPTemplate2(
    templateCatalogId: string,
    templateId: string,
    body: ApiLDAPUpdateLDAPTemplateBody,
    options?: any
  ) {
    return LDAPApiFp(this.configuration)
      .updateLDAPTemplate2(templateCatalogId, templateId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
