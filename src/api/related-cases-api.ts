// tslint:disable
/**
 * Webitel API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 24.04.0
 * Contact: support@webitel.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
import { Configuration } from '../configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base'
// @ts-ignore
import { CasesRelatedCase } from '../api'
// @ts-ignore
import { CasesRelatedCaseList } from '../api'
// @ts-ignore
import { GooglerpcStatus } from '../api'
// @ts-ignore
import { InlineObject2 } from '../api'
// @ts-ignore
import { InlineObject3 } from '../api'
/**
 * RelatedCasesApi - axios parameter creator
 * @export
 */
export const RelatedCasesApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} caseEtag new/existing comments belong to (id accepted)
     * @param {Array<string>} [fields] result fields needed on the front-end for each comment
     * @param {string} [inputEtag]
     * @param {'BlockedBy' | 'Blocks' | 'Duplicates' | 'DuplicatedBy' | 'Causes' | 'CausedBy' | 'IsChildOf' | 'IsParentOf' | 'RelatesTo'} [inputRelationType]  - Blocks: inversed  - DuplicatedBy: inversed  - CausedBy: inversed  - IsParentOf: inversed  - RelatesTo: bidirectional
     * @param {string} [inputRelatedToId] default, readonly system fields
     * @param {number} [inputRelatedToVer]
     * @param {string} [inputRelatedToEtag] main field required for read, update and delete
     * @param {string} [inputRelatedToCreatedById]
     * @param {string} [inputRelatedToCreatedByName]
     * @param {string} [inputRelatedToCreatedAt] unixmilli
     * @param {string} [inputRelatedToUpdatedById]
     * @param {string} [inputRelatedToUpdatedByName]
     * @param {string} [inputRelatedToUpdatedAt] unixmilli
     * @param {string} [inputRelatedToName] name of the case, formed by the prefix defined in Catalog and int, in docs uses as id
     * @param {string} [inputRelatedToSubject]
     * @param {string} [inputRelatedToDescription] free-form text to describe case
     * @param {string} [inputRelatedToContactInfo] free-form text to describe contact information
     * @param {string} [inputRelatedToPlannedReactionAt] planned reaction time calculated by sla and conditions, taking into account the calendar (unixmilli)
     * @param {string} [inputRelatedToPlannedResolveAt] planned resolve time calculated on-flight by sla and conditions, taking into account the calendar (unixmilli)
     * @param {string} [inputRelatedToStatusId]
     * @param {string} [inputRelatedToStatusName]
     * @param {string} [inputRelatedToCloseReasonGroupId]
     * @param {string} [inputRelatedToCloseReasonGroupName]
     * @param {string} [inputRelatedToAuthorId]
     * @param {string} [inputRelatedToAuthorName]
     * @param {string} [inputRelatedToAssigneeId]
     * @param {string} [inputRelatedToAssigneeName]
     * @param {string} [inputRelatedToReporterId]
     * @param {string} [inputRelatedToReporterName]
     * @param {string} [inputRelatedToImpactedId]
     * @param {string} [inputRelatedToImpactedName]
     * @param {string} [inputRelatedToGroupId]
     * @param {string} [inputRelatedToGroupName]
     * @param {string} [inputRelatedToPriorityId]
     * @param {string} [inputRelatedToPriorityName]
     * @param {string} [inputRelatedToSourceId]
     * @param {string} [inputRelatedToSourceName]
     * @param {string} [inputRelatedToStatusConditionId]
     * @param {string} [inputRelatedToStatusConditionName]
     * @param {string} [inputRelatedToCloseCloseResult] rich text with comment on resulting case
     * @param {string} [inputRelatedToCloseCloseReasonId]
     * @param {string} [inputRelatedToCloseCloseReasonName]
     * @param {string} [inputRelatedToRateRating] rating, formed from api calls
     * @param {string} [inputRelatedToRateRatingComment] (optional)
     * @param {string} [inputRelatedToTimingResolvedAt] actual time when this case was resolved
     * @param {string} [inputRelatedToTimingReactedAt] actual time when this case changed it\&#39;s status from initial
     * @param {string} [inputRelatedToTimingDifferenceInReaction] difference between actual and planned reaction time, taking into account the calendar
     * @param {string} [inputRelatedToTimingDifferenceInResolve] difference between actual and planned resolve time, taking into account the calendar
     * @param {string} [inputRelatedToServiceId]
     * @param {string} [inputRelatedToServiceName]
     * @param {string} [inputRelatedToCommentsPage] Current page number.
     * @param {boolean} [inputRelatedToCommentsNext] Flag to indicate if more pages are available.
     * @param {string} [inputRelatedToRelatedPage]
     * @param {boolean} [inputRelatedToRelatedNext]
     * @param {string} [inputRelatedToLinksPage]
     * @param {boolean} [inputRelatedToLinksNext]
     * @param {string} [inputRelatedToFilesPage] Current page number.
     * @param {boolean} [inputRelatedToFilesNext] Indicator if there is a next page.
     * @param {string} [inputRelatedToSlaId]
     * @param {string} [inputRelatedToSlaName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRelatedCase: async (
      caseEtag: string,
      fields?: Array<string>,
      inputEtag?: string,
      inputRelationType?:
        | 'BlockedBy'
        | 'Blocks'
        | 'Duplicates'
        | 'DuplicatedBy'
        | 'Causes'
        | 'CausedBy'
        | 'IsChildOf'
        | 'IsParentOf'
        | 'RelatesTo',
      inputRelatedToId?: string,
      inputRelatedToVer?: number,
      inputRelatedToEtag?: string,
      inputRelatedToCreatedById?: string,
      inputRelatedToCreatedByName?: string,
      inputRelatedToCreatedAt?: string,
      inputRelatedToUpdatedById?: string,
      inputRelatedToUpdatedByName?: string,
      inputRelatedToUpdatedAt?: string,
      inputRelatedToName?: string,
      inputRelatedToSubject?: string,
      inputRelatedToDescription?: string,
      inputRelatedToContactInfo?: string,
      inputRelatedToPlannedReactionAt?: string,
      inputRelatedToPlannedResolveAt?: string,
      inputRelatedToStatusId?: string,
      inputRelatedToStatusName?: string,
      inputRelatedToCloseReasonGroupId?: string,
      inputRelatedToCloseReasonGroupName?: string,
      inputRelatedToAuthorId?: string,
      inputRelatedToAuthorName?: string,
      inputRelatedToAssigneeId?: string,
      inputRelatedToAssigneeName?: string,
      inputRelatedToReporterId?: string,
      inputRelatedToReporterName?: string,
      inputRelatedToImpactedId?: string,
      inputRelatedToImpactedName?: string,
      inputRelatedToGroupId?: string,
      inputRelatedToGroupName?: string,
      inputRelatedToPriorityId?: string,
      inputRelatedToPriorityName?: string,
      inputRelatedToSourceId?: string,
      inputRelatedToSourceName?: string,
      inputRelatedToStatusConditionId?: string,
      inputRelatedToStatusConditionName?: string,
      inputRelatedToCloseCloseResult?: string,
      inputRelatedToCloseCloseReasonId?: string,
      inputRelatedToCloseCloseReasonName?: string,
      inputRelatedToRateRating?: string,
      inputRelatedToRateRatingComment?: string,
      inputRelatedToTimingResolvedAt?: string,
      inputRelatedToTimingReactedAt?: string,
      inputRelatedToTimingDifferenceInReaction?: string,
      inputRelatedToTimingDifferenceInResolve?: string,
      inputRelatedToServiceId?: string,
      inputRelatedToServiceName?: string,
      inputRelatedToCommentsPage?: string,
      inputRelatedToCommentsNext?: boolean,
      inputRelatedToRelatedPage?: string,
      inputRelatedToRelatedNext?: boolean,
      inputRelatedToLinksPage?: string,
      inputRelatedToLinksNext?: boolean,
      inputRelatedToFilesPage?: string,
      inputRelatedToFilesNext?: boolean,
      inputRelatedToSlaId?: string,
      inputRelatedToSlaName?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'caseEtag' is not null or undefined
      if (caseEtag === null || caseEtag === undefined) {
        throw new RequiredError(
          'caseEtag',
          'Required parameter caseEtag was null or undefined when calling createRelatedCase.'
        )
      }
      const localVarPath = `/cases/related/{caseEtag}`.replace(
        `{${'caseEtag'}}`,
        encodeURIComponent(String(caseEtag))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (inputEtag !== undefined) {
        localVarQueryParameter['input.etag'] = inputEtag
      }

      if (inputRelationType !== undefined) {
        localVarQueryParameter['input.relationType'] = inputRelationType
      }

      if (inputRelatedToId !== undefined) {
        localVarQueryParameter['input.relatedTo.id'] = inputRelatedToId
      }

      if (inputRelatedToVer !== undefined) {
        localVarQueryParameter['input.relatedTo.ver'] = inputRelatedToVer
      }

      if (inputRelatedToEtag !== undefined) {
        localVarQueryParameter['input.relatedTo.etag'] = inputRelatedToEtag
      }

      if (inputRelatedToCreatedById !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.createdBy.id'
        ] = inputRelatedToCreatedById
      }

      if (inputRelatedToCreatedByName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.createdBy.name'
        ] = inputRelatedToCreatedByName
      }

      if (inputRelatedToCreatedAt !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.createdAt'
        ] = inputRelatedToCreatedAt
      }

      if (inputRelatedToUpdatedById !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.updatedBy.id'
        ] = inputRelatedToUpdatedById
      }

      if (inputRelatedToUpdatedByName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.updatedBy.name'
        ] = inputRelatedToUpdatedByName
      }

      if (inputRelatedToUpdatedAt !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.updatedAt'
        ] = inputRelatedToUpdatedAt
      }

      if (inputRelatedToName !== undefined) {
        localVarQueryParameter['input.relatedTo.name'] = inputRelatedToName
      }

      if (inputRelatedToSubject !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.subject'
        ] = inputRelatedToSubject
      }

      if (inputRelatedToDescription !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.description'
        ] = inputRelatedToDescription
      }

      if (inputRelatedToContactInfo !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.contactInfo'
        ] = inputRelatedToContactInfo
      }

      if (inputRelatedToPlannedReactionAt !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.plannedReactionAt'
        ] = inputRelatedToPlannedReactionAt
      }

      if (inputRelatedToPlannedResolveAt !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.plannedResolveAt'
        ] = inputRelatedToPlannedResolveAt
      }

      if (inputRelatedToStatusId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.status.id'
        ] = inputRelatedToStatusId
      }

      if (inputRelatedToStatusName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.status.name'
        ] = inputRelatedToStatusName
      }

      if (inputRelatedToCloseReasonGroupId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.closeReasonGroup.id'
        ] = inputRelatedToCloseReasonGroupId
      }

      if (inputRelatedToCloseReasonGroupName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.closeReasonGroup.name'
        ] = inputRelatedToCloseReasonGroupName
      }

      if (inputRelatedToAuthorId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.author.id'
        ] = inputRelatedToAuthorId
      }

      if (inputRelatedToAuthorName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.author.name'
        ] = inputRelatedToAuthorName
      }

      if (inputRelatedToAssigneeId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.assignee.id'
        ] = inputRelatedToAssigneeId
      }

      if (inputRelatedToAssigneeName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.assignee.name'
        ] = inputRelatedToAssigneeName
      }

      if (inputRelatedToReporterId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.reporter.id'
        ] = inputRelatedToReporterId
      }

      if (inputRelatedToReporterName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.reporter.name'
        ] = inputRelatedToReporterName
      }

      if (inputRelatedToImpactedId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.impacted.id'
        ] = inputRelatedToImpactedId
      }

      if (inputRelatedToImpactedName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.impacted.name'
        ] = inputRelatedToImpactedName
      }

      if (inputRelatedToGroupId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.group.id'
        ] = inputRelatedToGroupId
      }

      if (inputRelatedToGroupName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.group.name'
        ] = inputRelatedToGroupName
      }

      if (inputRelatedToPriorityId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.priority.id'
        ] = inputRelatedToPriorityId
      }

      if (inputRelatedToPriorityName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.priority.name'
        ] = inputRelatedToPriorityName
      }

      if (inputRelatedToSourceId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.source.id'
        ] = inputRelatedToSourceId
      }

      if (inputRelatedToSourceName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.source.name'
        ] = inputRelatedToSourceName
      }

      if (inputRelatedToStatusConditionId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.statusCondition.id'
        ] = inputRelatedToStatusConditionId
      }

      if (inputRelatedToStatusConditionName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.statusCondition.name'
        ] = inputRelatedToStatusConditionName
      }

      if (inputRelatedToCloseCloseResult !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.close.closeResult'
        ] = inputRelatedToCloseCloseResult
      }

      if (inputRelatedToCloseCloseReasonId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.close.closeReason.id'
        ] = inputRelatedToCloseCloseReasonId
      }

      if (inputRelatedToCloseCloseReasonName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.close.closeReason.name'
        ] = inputRelatedToCloseCloseReasonName
      }

      if (inputRelatedToRateRating !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.rate.rating'
        ] = inputRelatedToRateRating
      }

      if (inputRelatedToRateRatingComment !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.rate.ratingComment'
        ] = inputRelatedToRateRatingComment
      }

      if (inputRelatedToTimingResolvedAt !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.timing.resolvedAt'
        ] = inputRelatedToTimingResolvedAt
      }

      if (inputRelatedToTimingReactedAt !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.timing.reactedAt'
        ] = inputRelatedToTimingReactedAt
      }

      if (inputRelatedToTimingDifferenceInReaction !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.timing.differenceInReaction'
        ] = inputRelatedToTimingDifferenceInReaction
      }

      if (inputRelatedToTimingDifferenceInResolve !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.timing.differenceInResolve'
        ] = inputRelatedToTimingDifferenceInResolve
      }

      if (inputRelatedToServiceId !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.service.id'
        ] = inputRelatedToServiceId
      }

      if (inputRelatedToServiceName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.service.name'
        ] = inputRelatedToServiceName
      }

      if (inputRelatedToCommentsPage !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.comments.page'
        ] = inputRelatedToCommentsPage
      }

      if (inputRelatedToCommentsNext !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.comments.next'
        ] = inputRelatedToCommentsNext
      }

      if (inputRelatedToRelatedPage !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.related.page'
        ] = inputRelatedToRelatedPage
      }

      if (inputRelatedToRelatedNext !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.related.next'
        ] = inputRelatedToRelatedNext
      }

      if (inputRelatedToLinksPage !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.links.page'
        ] = inputRelatedToLinksPage
      }

      if (inputRelatedToLinksNext !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.links.next'
        ] = inputRelatedToLinksNext
      }

      if (inputRelatedToFilesPage !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.files.page'
        ] = inputRelatedToFilesPage
      }

      if (inputRelatedToFilesNext !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.files.next'
        ] = inputRelatedToFilesNext
      }

      if (inputRelatedToSlaId !== undefined) {
        localVarQueryParameter['input.relatedTo.sla.id'] = inputRelatedToSlaId
      }

      if (inputRelatedToSlaName !== undefined) {
        localVarQueryParameter[
          'input.relatedTo.sla.name'
        ] = inputRelatedToSlaName
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} etag (etag only)
     * @param {Array<string>} [fields] fields on return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRelatedCase: async (
      etag: string,
      fields?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'etag' is not null or undefined
      if (etag === null || etag === undefined) {
        throw new RequiredError(
          'etag',
          'Required parameter etag was null or undefined when calling deleteRelatedCase.'
        )
      }
      const localVarPath = `/cases/related/{etag}`.replace(
        `{${'etag'}}`,
        encodeURIComponent(String(etag))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The related cases can be obtained bidirectionally as child or parent, but we should consider them from the perspective of the requested case, by inverting their connection type Requested case always a parent and related cases a children
     * @param {string} caseEtag
     * @param {string} [page]
     * @param {string} [size]
     * @param {string} [q]
     * @param {Array<string>} [qin]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRelatedCases: async (
      caseEtag: string,
      page?: string,
      size?: string,
      q?: string,
      qin?: Array<string>,
      sort?: string,
      fields?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'caseEtag' is not null or undefined
      if (caseEtag === null || caseEtag === undefined) {
        throw new RequiredError(
          'caseEtag',
          'Required parameter caseEtag was null or undefined when calling listRelatedCases.'
        )
      }
      const localVarPath = `/cases/{caseEtag}/related`.replace(
        `{${'caseEtag'}}`,
        encodeURIComponent(String(caseEtag))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (qin) {
        localVarQueryParameter['qin'] = qin
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} etag (id allowed)
     * @param {Array<string>} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    locateRelatedCase: async (
      etag: string,
      fields?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'etag' is not null or undefined
      if (etag === null || etag === undefined) {
        throw new RequiredError(
          'etag',
          'Required parameter etag was null or undefined when calling locateRelatedCase.'
        )
      }
      const localVarPath = `/cases/related/{etag}`.replace(
        `{${'etag'}}`,
        encodeURIComponent(String(etag))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} inputEtag
     * @param {InlineObject2} input
     * @param {Array<string>} [fields] on return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRelatedCase: async (
      inputEtag: string,
      input: InlineObject2,
      fields?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'inputEtag' is not null or undefined
      if (inputEtag === null || inputEtag === undefined) {
        throw new RequiredError(
          'inputEtag',
          'Required parameter inputEtag was null or undefined when calling updateRelatedCase.'
        )
      }
      // verify required parameter 'input' is not null or undefined
      if (input === null || input === undefined) {
        throw new RequiredError(
          'input',
          'Required parameter input was null or undefined when calling updateRelatedCase.'
        )
      }
      const localVarPath = `/cases/related/{input.etag}`.replace(
        `{${'input.etag'}}`,
        encodeURIComponent(String(inputEtag))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof input !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(input !== undefined ? input : {})
        : input || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} inputEtag
     * @param {InlineObject3} input
     * @param {Array<string>} [fields] on return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRelatedCase2: async (
      inputEtag: string,
      input: InlineObject3,
      fields?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'inputEtag' is not null or undefined
      if (inputEtag === null || inputEtag === undefined) {
        throw new RequiredError(
          'inputEtag',
          'Required parameter inputEtag was null or undefined when calling updateRelatedCase2.'
        )
      }
      // verify required parameter 'input' is not null or undefined
      if (input === null || input === undefined) {
        throw new RequiredError(
          'input',
          'Required parameter input was null or undefined when calling updateRelatedCase2.'
        )
      }
      const localVarPath = `/cases/related/{input.etag}`.replace(
        `{${'input.etag'}}`,
        encodeURIComponent(String(inputEtag))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof input !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(input !== undefined ? input : {})
        : input || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RelatedCasesApi - functional programming interface
 * @export
 */
export const RelatedCasesApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} caseEtag new/existing comments belong to (id accepted)
     * @param {Array<string>} [fields] result fields needed on the front-end for each comment
     * @param {string} [inputEtag]
     * @param {'BlockedBy' | 'Blocks' | 'Duplicates' | 'DuplicatedBy' | 'Causes' | 'CausedBy' | 'IsChildOf' | 'IsParentOf' | 'RelatesTo'} [inputRelationType]  - Blocks: inversed  - DuplicatedBy: inversed  - CausedBy: inversed  - IsParentOf: inversed  - RelatesTo: bidirectional
     * @param {string} [inputRelatedToId] default, readonly system fields
     * @param {number} [inputRelatedToVer]
     * @param {string} [inputRelatedToEtag] main field required for read, update and delete
     * @param {string} [inputRelatedToCreatedById]
     * @param {string} [inputRelatedToCreatedByName]
     * @param {string} [inputRelatedToCreatedAt] unixmilli
     * @param {string} [inputRelatedToUpdatedById]
     * @param {string} [inputRelatedToUpdatedByName]
     * @param {string} [inputRelatedToUpdatedAt] unixmilli
     * @param {string} [inputRelatedToName] name of the case, formed by the prefix defined in Catalog and int, in docs uses as id
     * @param {string} [inputRelatedToSubject]
     * @param {string} [inputRelatedToDescription] free-form text to describe case
     * @param {string} [inputRelatedToContactInfo] free-form text to describe contact information
     * @param {string} [inputRelatedToPlannedReactionAt] planned reaction time calculated by sla and conditions, taking into account the calendar (unixmilli)
     * @param {string} [inputRelatedToPlannedResolveAt] planned resolve time calculated on-flight by sla and conditions, taking into account the calendar (unixmilli)
     * @param {string} [inputRelatedToStatusId]
     * @param {string} [inputRelatedToStatusName]
     * @param {string} [inputRelatedToCloseReasonGroupId]
     * @param {string} [inputRelatedToCloseReasonGroupName]
     * @param {string} [inputRelatedToAuthorId]
     * @param {string} [inputRelatedToAuthorName]
     * @param {string} [inputRelatedToAssigneeId]
     * @param {string} [inputRelatedToAssigneeName]
     * @param {string} [inputRelatedToReporterId]
     * @param {string} [inputRelatedToReporterName]
     * @param {string} [inputRelatedToImpactedId]
     * @param {string} [inputRelatedToImpactedName]
     * @param {string} [inputRelatedToGroupId]
     * @param {string} [inputRelatedToGroupName]
     * @param {string} [inputRelatedToPriorityId]
     * @param {string} [inputRelatedToPriorityName]
     * @param {string} [inputRelatedToSourceId]
     * @param {string} [inputRelatedToSourceName]
     * @param {string} [inputRelatedToStatusConditionId]
     * @param {string} [inputRelatedToStatusConditionName]
     * @param {string} [inputRelatedToCloseCloseResult] rich text with comment on resulting case
     * @param {string} [inputRelatedToCloseCloseReasonId]
     * @param {string} [inputRelatedToCloseCloseReasonName]
     * @param {string} [inputRelatedToRateRating] rating, formed from api calls
     * @param {string} [inputRelatedToRateRatingComment] (optional)
     * @param {string} [inputRelatedToTimingResolvedAt] actual time when this case was resolved
     * @param {string} [inputRelatedToTimingReactedAt] actual time when this case changed it\&#39;s status from initial
     * @param {string} [inputRelatedToTimingDifferenceInReaction] difference between actual and planned reaction time, taking into account the calendar
     * @param {string} [inputRelatedToTimingDifferenceInResolve] difference between actual and planned resolve time, taking into account the calendar
     * @param {string} [inputRelatedToServiceId]
     * @param {string} [inputRelatedToServiceName]
     * @param {string} [inputRelatedToCommentsPage] Current page number.
     * @param {boolean} [inputRelatedToCommentsNext] Flag to indicate if more pages are available.
     * @param {string} [inputRelatedToRelatedPage]
     * @param {boolean} [inputRelatedToRelatedNext]
     * @param {string} [inputRelatedToLinksPage]
     * @param {boolean} [inputRelatedToLinksNext]
     * @param {string} [inputRelatedToFilesPage] Current page number.
     * @param {boolean} [inputRelatedToFilesNext] Indicator if there is a next page.
     * @param {string} [inputRelatedToSlaId]
     * @param {string} [inputRelatedToSlaName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRelatedCase(
      caseEtag: string,
      fields?: Array<string>,
      inputEtag?: string,
      inputRelationType?:
        | 'BlockedBy'
        | 'Blocks'
        | 'Duplicates'
        | 'DuplicatedBy'
        | 'Causes'
        | 'CausedBy'
        | 'IsChildOf'
        | 'IsParentOf'
        | 'RelatesTo',
      inputRelatedToId?: string,
      inputRelatedToVer?: number,
      inputRelatedToEtag?: string,
      inputRelatedToCreatedById?: string,
      inputRelatedToCreatedByName?: string,
      inputRelatedToCreatedAt?: string,
      inputRelatedToUpdatedById?: string,
      inputRelatedToUpdatedByName?: string,
      inputRelatedToUpdatedAt?: string,
      inputRelatedToName?: string,
      inputRelatedToSubject?: string,
      inputRelatedToDescription?: string,
      inputRelatedToContactInfo?: string,
      inputRelatedToPlannedReactionAt?: string,
      inputRelatedToPlannedResolveAt?: string,
      inputRelatedToStatusId?: string,
      inputRelatedToStatusName?: string,
      inputRelatedToCloseReasonGroupId?: string,
      inputRelatedToCloseReasonGroupName?: string,
      inputRelatedToAuthorId?: string,
      inputRelatedToAuthorName?: string,
      inputRelatedToAssigneeId?: string,
      inputRelatedToAssigneeName?: string,
      inputRelatedToReporterId?: string,
      inputRelatedToReporterName?: string,
      inputRelatedToImpactedId?: string,
      inputRelatedToImpactedName?: string,
      inputRelatedToGroupId?: string,
      inputRelatedToGroupName?: string,
      inputRelatedToPriorityId?: string,
      inputRelatedToPriorityName?: string,
      inputRelatedToSourceId?: string,
      inputRelatedToSourceName?: string,
      inputRelatedToStatusConditionId?: string,
      inputRelatedToStatusConditionName?: string,
      inputRelatedToCloseCloseResult?: string,
      inputRelatedToCloseCloseReasonId?: string,
      inputRelatedToCloseCloseReasonName?: string,
      inputRelatedToRateRating?: string,
      inputRelatedToRateRatingComment?: string,
      inputRelatedToTimingResolvedAt?: string,
      inputRelatedToTimingReactedAt?: string,
      inputRelatedToTimingDifferenceInReaction?: string,
      inputRelatedToTimingDifferenceInResolve?: string,
      inputRelatedToServiceId?: string,
      inputRelatedToServiceName?: string,
      inputRelatedToCommentsPage?: string,
      inputRelatedToCommentsNext?: boolean,
      inputRelatedToRelatedPage?: string,
      inputRelatedToRelatedNext?: boolean,
      inputRelatedToLinksPage?: string,
      inputRelatedToLinksNext?: boolean,
      inputRelatedToFilesPage?: string,
      inputRelatedToFilesNext?: boolean,
      inputRelatedToSlaId?: string,
      inputRelatedToSlaName?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CasesRelatedCase>
    > {
      const localVarAxiosArgs = await RelatedCasesApiAxiosParamCreator(
        configuration
      ).createRelatedCase(
        caseEtag,
        fields,
        inputEtag,
        inputRelationType,
        inputRelatedToId,
        inputRelatedToVer,
        inputRelatedToEtag,
        inputRelatedToCreatedById,
        inputRelatedToCreatedByName,
        inputRelatedToCreatedAt,
        inputRelatedToUpdatedById,
        inputRelatedToUpdatedByName,
        inputRelatedToUpdatedAt,
        inputRelatedToName,
        inputRelatedToSubject,
        inputRelatedToDescription,
        inputRelatedToContactInfo,
        inputRelatedToPlannedReactionAt,
        inputRelatedToPlannedResolveAt,
        inputRelatedToStatusId,
        inputRelatedToStatusName,
        inputRelatedToCloseReasonGroupId,
        inputRelatedToCloseReasonGroupName,
        inputRelatedToAuthorId,
        inputRelatedToAuthorName,
        inputRelatedToAssigneeId,
        inputRelatedToAssigneeName,
        inputRelatedToReporterId,
        inputRelatedToReporterName,
        inputRelatedToImpactedId,
        inputRelatedToImpactedName,
        inputRelatedToGroupId,
        inputRelatedToGroupName,
        inputRelatedToPriorityId,
        inputRelatedToPriorityName,
        inputRelatedToSourceId,
        inputRelatedToSourceName,
        inputRelatedToStatusConditionId,
        inputRelatedToStatusConditionName,
        inputRelatedToCloseCloseResult,
        inputRelatedToCloseCloseReasonId,
        inputRelatedToCloseCloseReasonName,
        inputRelatedToRateRating,
        inputRelatedToRateRatingComment,
        inputRelatedToTimingResolvedAt,
        inputRelatedToTimingReactedAt,
        inputRelatedToTimingDifferenceInReaction,
        inputRelatedToTimingDifferenceInResolve,
        inputRelatedToServiceId,
        inputRelatedToServiceName,
        inputRelatedToCommentsPage,
        inputRelatedToCommentsNext,
        inputRelatedToRelatedPage,
        inputRelatedToRelatedNext,
        inputRelatedToLinksPage,
        inputRelatedToLinksNext,
        inputRelatedToFilesPage,
        inputRelatedToFilesNext,
        inputRelatedToSlaId,
        inputRelatedToSlaName,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} etag (etag only)
     * @param {Array<string>} [fields] fields on return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRelatedCase(
      etag: string,
      fields?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CasesRelatedCase>
    > {
      const localVarAxiosArgs = await RelatedCasesApiAxiosParamCreator(
        configuration
      ).deleteRelatedCase(etag, fields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary The related cases can be obtained bidirectionally as child or parent, but we should consider them from the perspective of the requested case, by inverting their connection type Requested case always a parent and related cases a children
     * @param {string} caseEtag
     * @param {string} [page]
     * @param {string} [size]
     * @param {string} [q]
     * @param {Array<string>} [qin]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRelatedCases(
      caseEtag: string,
      page?: string,
      size?: string,
      q?: string,
      qin?: Array<string>,
      sort?: string,
      fields?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CasesRelatedCaseList>
    > {
      const localVarAxiosArgs = await RelatedCasesApiAxiosParamCreator(
        configuration
      ).listRelatedCases(caseEtag, page, size, q, qin, sort, fields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} etag (id allowed)
     * @param {Array<string>} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async locateRelatedCase(
      etag: string,
      fields?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CasesRelatedCase>
    > {
      const localVarAxiosArgs = await RelatedCasesApiAxiosParamCreator(
        configuration
      ).locateRelatedCase(etag, fields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} inputEtag
     * @param {InlineObject2} input
     * @param {Array<string>} [fields] on return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRelatedCase(
      inputEtag: string,
      input: InlineObject2,
      fields?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CasesRelatedCase>
    > {
      const localVarAxiosArgs = await RelatedCasesApiAxiosParamCreator(
        configuration
      ).updateRelatedCase(inputEtag, input, fields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} inputEtag
     * @param {InlineObject3} input
     * @param {Array<string>} [fields] on return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRelatedCase2(
      inputEtag: string,
      input: InlineObject3,
      fields?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CasesRelatedCase>
    > {
      const localVarAxiosArgs = await RelatedCasesApiAxiosParamCreator(
        configuration
      ).updateRelatedCase2(inputEtag, input, fields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * RelatedCasesApi - factory interface
 * @export
 */
export const RelatedCasesApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {string} caseEtag new/existing comments belong to (id accepted)
     * @param {Array<string>} [fields] result fields needed on the front-end for each comment
     * @param {string} [inputEtag]
     * @param {'BlockedBy' | 'Blocks' | 'Duplicates' | 'DuplicatedBy' | 'Causes' | 'CausedBy' | 'IsChildOf' | 'IsParentOf' | 'RelatesTo'} [inputRelationType]  - Blocks: inversed  - DuplicatedBy: inversed  - CausedBy: inversed  - IsParentOf: inversed  - RelatesTo: bidirectional
     * @param {string} [inputRelatedToId] default, readonly system fields
     * @param {number} [inputRelatedToVer]
     * @param {string} [inputRelatedToEtag] main field required for read, update and delete
     * @param {string} [inputRelatedToCreatedById]
     * @param {string} [inputRelatedToCreatedByName]
     * @param {string} [inputRelatedToCreatedAt] unixmilli
     * @param {string} [inputRelatedToUpdatedById]
     * @param {string} [inputRelatedToUpdatedByName]
     * @param {string} [inputRelatedToUpdatedAt] unixmilli
     * @param {string} [inputRelatedToName] name of the case, formed by the prefix defined in Catalog and int, in docs uses as id
     * @param {string} [inputRelatedToSubject]
     * @param {string} [inputRelatedToDescription] free-form text to describe case
     * @param {string} [inputRelatedToContactInfo] free-form text to describe contact information
     * @param {string} [inputRelatedToPlannedReactionAt] planned reaction time calculated by sla and conditions, taking into account the calendar (unixmilli)
     * @param {string} [inputRelatedToPlannedResolveAt] planned resolve time calculated on-flight by sla and conditions, taking into account the calendar (unixmilli)
     * @param {string} [inputRelatedToStatusId]
     * @param {string} [inputRelatedToStatusName]
     * @param {string} [inputRelatedToCloseReasonGroupId]
     * @param {string} [inputRelatedToCloseReasonGroupName]
     * @param {string} [inputRelatedToAuthorId]
     * @param {string} [inputRelatedToAuthorName]
     * @param {string} [inputRelatedToAssigneeId]
     * @param {string} [inputRelatedToAssigneeName]
     * @param {string} [inputRelatedToReporterId]
     * @param {string} [inputRelatedToReporterName]
     * @param {string} [inputRelatedToImpactedId]
     * @param {string} [inputRelatedToImpactedName]
     * @param {string} [inputRelatedToGroupId]
     * @param {string} [inputRelatedToGroupName]
     * @param {string} [inputRelatedToPriorityId]
     * @param {string} [inputRelatedToPriorityName]
     * @param {string} [inputRelatedToSourceId]
     * @param {string} [inputRelatedToSourceName]
     * @param {string} [inputRelatedToStatusConditionId]
     * @param {string} [inputRelatedToStatusConditionName]
     * @param {string} [inputRelatedToCloseCloseResult] rich text with comment on resulting case
     * @param {string} [inputRelatedToCloseCloseReasonId]
     * @param {string} [inputRelatedToCloseCloseReasonName]
     * @param {string} [inputRelatedToRateRating] rating, formed from api calls
     * @param {string} [inputRelatedToRateRatingComment] (optional)
     * @param {string} [inputRelatedToTimingResolvedAt] actual time when this case was resolved
     * @param {string} [inputRelatedToTimingReactedAt] actual time when this case changed it\&#39;s status from initial
     * @param {string} [inputRelatedToTimingDifferenceInReaction] difference between actual and planned reaction time, taking into account the calendar
     * @param {string} [inputRelatedToTimingDifferenceInResolve] difference between actual and planned resolve time, taking into account the calendar
     * @param {string} [inputRelatedToServiceId]
     * @param {string} [inputRelatedToServiceName]
     * @param {string} [inputRelatedToCommentsPage] Current page number.
     * @param {boolean} [inputRelatedToCommentsNext] Flag to indicate if more pages are available.
     * @param {string} [inputRelatedToRelatedPage]
     * @param {boolean} [inputRelatedToRelatedNext]
     * @param {string} [inputRelatedToLinksPage]
     * @param {boolean} [inputRelatedToLinksNext]
     * @param {string} [inputRelatedToFilesPage] Current page number.
     * @param {boolean} [inputRelatedToFilesNext] Indicator if there is a next page.
     * @param {string} [inputRelatedToSlaId]
     * @param {string} [inputRelatedToSlaName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRelatedCase(
      caseEtag: string,
      fields?: Array<string>,
      inputEtag?: string,
      inputRelationType?:
        | 'BlockedBy'
        | 'Blocks'
        | 'Duplicates'
        | 'DuplicatedBy'
        | 'Causes'
        | 'CausedBy'
        | 'IsChildOf'
        | 'IsParentOf'
        | 'RelatesTo',
      inputRelatedToId?: string,
      inputRelatedToVer?: number,
      inputRelatedToEtag?: string,
      inputRelatedToCreatedById?: string,
      inputRelatedToCreatedByName?: string,
      inputRelatedToCreatedAt?: string,
      inputRelatedToUpdatedById?: string,
      inputRelatedToUpdatedByName?: string,
      inputRelatedToUpdatedAt?: string,
      inputRelatedToName?: string,
      inputRelatedToSubject?: string,
      inputRelatedToDescription?: string,
      inputRelatedToContactInfo?: string,
      inputRelatedToPlannedReactionAt?: string,
      inputRelatedToPlannedResolveAt?: string,
      inputRelatedToStatusId?: string,
      inputRelatedToStatusName?: string,
      inputRelatedToCloseReasonGroupId?: string,
      inputRelatedToCloseReasonGroupName?: string,
      inputRelatedToAuthorId?: string,
      inputRelatedToAuthorName?: string,
      inputRelatedToAssigneeId?: string,
      inputRelatedToAssigneeName?: string,
      inputRelatedToReporterId?: string,
      inputRelatedToReporterName?: string,
      inputRelatedToImpactedId?: string,
      inputRelatedToImpactedName?: string,
      inputRelatedToGroupId?: string,
      inputRelatedToGroupName?: string,
      inputRelatedToPriorityId?: string,
      inputRelatedToPriorityName?: string,
      inputRelatedToSourceId?: string,
      inputRelatedToSourceName?: string,
      inputRelatedToStatusConditionId?: string,
      inputRelatedToStatusConditionName?: string,
      inputRelatedToCloseCloseResult?: string,
      inputRelatedToCloseCloseReasonId?: string,
      inputRelatedToCloseCloseReasonName?: string,
      inputRelatedToRateRating?: string,
      inputRelatedToRateRatingComment?: string,
      inputRelatedToTimingResolvedAt?: string,
      inputRelatedToTimingReactedAt?: string,
      inputRelatedToTimingDifferenceInReaction?: string,
      inputRelatedToTimingDifferenceInResolve?: string,
      inputRelatedToServiceId?: string,
      inputRelatedToServiceName?: string,
      inputRelatedToCommentsPage?: string,
      inputRelatedToCommentsNext?: boolean,
      inputRelatedToRelatedPage?: string,
      inputRelatedToRelatedNext?: boolean,
      inputRelatedToLinksPage?: string,
      inputRelatedToLinksNext?: boolean,
      inputRelatedToFilesPage?: string,
      inputRelatedToFilesNext?: boolean,
      inputRelatedToSlaId?: string,
      inputRelatedToSlaName?: string,
      options?: any
    ): AxiosPromise<CasesRelatedCase> {
      return RelatedCasesApiFp(configuration)
        .createRelatedCase(
          caseEtag,
          fields,
          inputEtag,
          inputRelationType,
          inputRelatedToId,
          inputRelatedToVer,
          inputRelatedToEtag,
          inputRelatedToCreatedById,
          inputRelatedToCreatedByName,
          inputRelatedToCreatedAt,
          inputRelatedToUpdatedById,
          inputRelatedToUpdatedByName,
          inputRelatedToUpdatedAt,
          inputRelatedToName,
          inputRelatedToSubject,
          inputRelatedToDescription,
          inputRelatedToContactInfo,
          inputRelatedToPlannedReactionAt,
          inputRelatedToPlannedResolveAt,
          inputRelatedToStatusId,
          inputRelatedToStatusName,
          inputRelatedToCloseReasonGroupId,
          inputRelatedToCloseReasonGroupName,
          inputRelatedToAuthorId,
          inputRelatedToAuthorName,
          inputRelatedToAssigneeId,
          inputRelatedToAssigneeName,
          inputRelatedToReporterId,
          inputRelatedToReporterName,
          inputRelatedToImpactedId,
          inputRelatedToImpactedName,
          inputRelatedToGroupId,
          inputRelatedToGroupName,
          inputRelatedToPriorityId,
          inputRelatedToPriorityName,
          inputRelatedToSourceId,
          inputRelatedToSourceName,
          inputRelatedToStatusConditionId,
          inputRelatedToStatusConditionName,
          inputRelatedToCloseCloseResult,
          inputRelatedToCloseCloseReasonId,
          inputRelatedToCloseCloseReasonName,
          inputRelatedToRateRating,
          inputRelatedToRateRatingComment,
          inputRelatedToTimingResolvedAt,
          inputRelatedToTimingReactedAt,
          inputRelatedToTimingDifferenceInReaction,
          inputRelatedToTimingDifferenceInResolve,
          inputRelatedToServiceId,
          inputRelatedToServiceName,
          inputRelatedToCommentsPage,
          inputRelatedToCommentsNext,
          inputRelatedToRelatedPage,
          inputRelatedToRelatedNext,
          inputRelatedToLinksPage,
          inputRelatedToLinksNext,
          inputRelatedToFilesPage,
          inputRelatedToFilesNext,
          inputRelatedToSlaId,
          inputRelatedToSlaName,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} etag (etag only)
     * @param {Array<string>} [fields] fields on return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRelatedCase(
      etag: string,
      fields?: Array<string>,
      options?: any
    ): AxiosPromise<CasesRelatedCase> {
      return RelatedCasesApiFp(configuration)
        .deleteRelatedCase(etag, fields, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The related cases can be obtained bidirectionally as child or parent, but we should consider them from the perspective of the requested case, by inverting their connection type Requested case always a parent and related cases a children
     * @param {string} caseEtag
     * @param {string} [page]
     * @param {string} [size]
     * @param {string} [q]
     * @param {Array<string>} [qin]
     * @param {string} [sort]
     * @param {Array<string>} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRelatedCases(
      caseEtag: string,
      page?: string,
      size?: string,
      q?: string,
      qin?: Array<string>,
      sort?: string,
      fields?: Array<string>,
      options?: any
    ): AxiosPromise<CasesRelatedCaseList> {
      return RelatedCasesApiFp(configuration)
        .listRelatedCases(caseEtag, page, size, q, qin, sort, fields, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} etag (id allowed)
     * @param {Array<string>} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    locateRelatedCase(
      etag: string,
      fields?: Array<string>,
      options?: any
    ): AxiosPromise<CasesRelatedCase> {
      return RelatedCasesApiFp(configuration)
        .locateRelatedCase(etag, fields, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} inputEtag
     * @param {InlineObject2} input
     * @param {Array<string>} [fields] on return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRelatedCase(
      inputEtag: string,
      input: InlineObject2,
      fields?: Array<string>,
      options?: any
    ): AxiosPromise<CasesRelatedCase> {
      return RelatedCasesApiFp(configuration)
        .updateRelatedCase(inputEtag, input, fields, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} inputEtag
     * @param {InlineObject3} input
     * @param {Array<string>} [fields] on return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRelatedCase2(
      inputEtag: string,
      input: InlineObject3,
      fields?: Array<string>,
      options?: any
    ): AxiosPromise<CasesRelatedCase> {
      return RelatedCasesApiFp(configuration)
        .updateRelatedCase2(inputEtag, input, fields, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RelatedCasesApi - object-oriented interface
 * @export
 * @class RelatedCasesApi
 * @extends {BaseAPI}
 */
export class RelatedCasesApi extends BaseAPI {
  /**
   *
   * @param {string} caseEtag new/existing comments belong to (id accepted)
   * @param {Array<string>} [fields] result fields needed on the front-end for each comment
   * @param {string} [inputEtag]
   * @param {'BlockedBy' | 'Blocks' | 'Duplicates' | 'DuplicatedBy' | 'Causes' | 'CausedBy' | 'IsChildOf' | 'IsParentOf' | 'RelatesTo'} [inputRelationType]  - Blocks: inversed  - DuplicatedBy: inversed  - CausedBy: inversed  - IsParentOf: inversed  - RelatesTo: bidirectional
   * @param {string} [inputRelatedToId] default, readonly system fields
   * @param {number} [inputRelatedToVer]
   * @param {string} [inputRelatedToEtag] main field required for read, update and delete
   * @param {string} [inputRelatedToCreatedById]
   * @param {string} [inputRelatedToCreatedByName]
   * @param {string} [inputRelatedToCreatedAt] unixmilli
   * @param {string} [inputRelatedToUpdatedById]
   * @param {string} [inputRelatedToUpdatedByName]
   * @param {string} [inputRelatedToUpdatedAt] unixmilli
   * @param {string} [inputRelatedToName] name of the case, formed by the prefix defined in Catalog and int, in docs uses as id
   * @param {string} [inputRelatedToSubject]
   * @param {string} [inputRelatedToDescription] free-form text to describe case
   * @param {string} [inputRelatedToContactInfo] free-form text to describe contact information
   * @param {string} [inputRelatedToPlannedReactionAt] planned reaction time calculated by sla and conditions, taking into account the calendar (unixmilli)
   * @param {string} [inputRelatedToPlannedResolveAt] planned resolve time calculated on-flight by sla and conditions, taking into account the calendar (unixmilli)
   * @param {string} [inputRelatedToStatusId]
   * @param {string} [inputRelatedToStatusName]
   * @param {string} [inputRelatedToCloseReasonGroupId]
   * @param {string} [inputRelatedToCloseReasonGroupName]
   * @param {string} [inputRelatedToAuthorId]
   * @param {string} [inputRelatedToAuthorName]
   * @param {string} [inputRelatedToAssigneeId]
   * @param {string} [inputRelatedToAssigneeName]
   * @param {string} [inputRelatedToReporterId]
   * @param {string} [inputRelatedToReporterName]
   * @param {string} [inputRelatedToImpactedId]
   * @param {string} [inputRelatedToImpactedName]
   * @param {string} [inputRelatedToGroupId]
   * @param {string} [inputRelatedToGroupName]
   * @param {string} [inputRelatedToPriorityId]
   * @param {string} [inputRelatedToPriorityName]
   * @param {string} [inputRelatedToSourceId]
   * @param {string} [inputRelatedToSourceName]
   * @param {string} [inputRelatedToStatusConditionId]
   * @param {string} [inputRelatedToStatusConditionName]
   * @param {string} [inputRelatedToCloseCloseResult] rich text with comment on resulting case
   * @param {string} [inputRelatedToCloseCloseReasonId]
   * @param {string} [inputRelatedToCloseCloseReasonName]
   * @param {string} [inputRelatedToRateRating] rating, formed from api calls
   * @param {string} [inputRelatedToRateRatingComment] (optional)
   * @param {string} [inputRelatedToTimingResolvedAt] actual time when this case was resolved
   * @param {string} [inputRelatedToTimingReactedAt] actual time when this case changed it\&#39;s status from initial
   * @param {string} [inputRelatedToTimingDifferenceInReaction] difference between actual and planned reaction time, taking into account the calendar
   * @param {string} [inputRelatedToTimingDifferenceInResolve] difference between actual and planned resolve time, taking into account the calendar
   * @param {string} [inputRelatedToServiceId]
   * @param {string} [inputRelatedToServiceName]
   * @param {string} [inputRelatedToCommentsPage] Current page number.
   * @param {boolean} [inputRelatedToCommentsNext] Flag to indicate if more pages are available.
   * @param {string} [inputRelatedToRelatedPage]
   * @param {boolean} [inputRelatedToRelatedNext]
   * @param {string} [inputRelatedToLinksPage]
   * @param {boolean} [inputRelatedToLinksNext]
   * @param {string} [inputRelatedToFilesPage] Current page number.
   * @param {boolean} [inputRelatedToFilesNext] Indicator if there is a next page.
   * @param {string} [inputRelatedToSlaId]
   * @param {string} [inputRelatedToSlaName]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelatedCasesApi
   */
  public createRelatedCase(
    caseEtag: string,
    fields?: Array<string>,
    inputEtag?: string,
    inputRelationType?:
      | 'BlockedBy'
      | 'Blocks'
      | 'Duplicates'
      | 'DuplicatedBy'
      | 'Causes'
      | 'CausedBy'
      | 'IsChildOf'
      | 'IsParentOf'
      | 'RelatesTo',
    inputRelatedToId?: string,
    inputRelatedToVer?: number,
    inputRelatedToEtag?: string,
    inputRelatedToCreatedById?: string,
    inputRelatedToCreatedByName?: string,
    inputRelatedToCreatedAt?: string,
    inputRelatedToUpdatedById?: string,
    inputRelatedToUpdatedByName?: string,
    inputRelatedToUpdatedAt?: string,
    inputRelatedToName?: string,
    inputRelatedToSubject?: string,
    inputRelatedToDescription?: string,
    inputRelatedToContactInfo?: string,
    inputRelatedToPlannedReactionAt?: string,
    inputRelatedToPlannedResolveAt?: string,
    inputRelatedToStatusId?: string,
    inputRelatedToStatusName?: string,
    inputRelatedToCloseReasonGroupId?: string,
    inputRelatedToCloseReasonGroupName?: string,
    inputRelatedToAuthorId?: string,
    inputRelatedToAuthorName?: string,
    inputRelatedToAssigneeId?: string,
    inputRelatedToAssigneeName?: string,
    inputRelatedToReporterId?: string,
    inputRelatedToReporterName?: string,
    inputRelatedToImpactedId?: string,
    inputRelatedToImpactedName?: string,
    inputRelatedToGroupId?: string,
    inputRelatedToGroupName?: string,
    inputRelatedToPriorityId?: string,
    inputRelatedToPriorityName?: string,
    inputRelatedToSourceId?: string,
    inputRelatedToSourceName?: string,
    inputRelatedToStatusConditionId?: string,
    inputRelatedToStatusConditionName?: string,
    inputRelatedToCloseCloseResult?: string,
    inputRelatedToCloseCloseReasonId?: string,
    inputRelatedToCloseCloseReasonName?: string,
    inputRelatedToRateRating?: string,
    inputRelatedToRateRatingComment?: string,
    inputRelatedToTimingResolvedAt?: string,
    inputRelatedToTimingReactedAt?: string,
    inputRelatedToTimingDifferenceInReaction?: string,
    inputRelatedToTimingDifferenceInResolve?: string,
    inputRelatedToServiceId?: string,
    inputRelatedToServiceName?: string,
    inputRelatedToCommentsPage?: string,
    inputRelatedToCommentsNext?: boolean,
    inputRelatedToRelatedPage?: string,
    inputRelatedToRelatedNext?: boolean,
    inputRelatedToLinksPage?: string,
    inputRelatedToLinksNext?: boolean,
    inputRelatedToFilesPage?: string,
    inputRelatedToFilesNext?: boolean,
    inputRelatedToSlaId?: string,
    inputRelatedToSlaName?: string,
    options?: any
  ) {
    return RelatedCasesApiFp(this.configuration)
      .createRelatedCase(
        caseEtag,
        fields,
        inputEtag,
        inputRelationType,
        inputRelatedToId,
        inputRelatedToVer,
        inputRelatedToEtag,
        inputRelatedToCreatedById,
        inputRelatedToCreatedByName,
        inputRelatedToCreatedAt,
        inputRelatedToUpdatedById,
        inputRelatedToUpdatedByName,
        inputRelatedToUpdatedAt,
        inputRelatedToName,
        inputRelatedToSubject,
        inputRelatedToDescription,
        inputRelatedToContactInfo,
        inputRelatedToPlannedReactionAt,
        inputRelatedToPlannedResolveAt,
        inputRelatedToStatusId,
        inputRelatedToStatusName,
        inputRelatedToCloseReasonGroupId,
        inputRelatedToCloseReasonGroupName,
        inputRelatedToAuthorId,
        inputRelatedToAuthorName,
        inputRelatedToAssigneeId,
        inputRelatedToAssigneeName,
        inputRelatedToReporterId,
        inputRelatedToReporterName,
        inputRelatedToImpactedId,
        inputRelatedToImpactedName,
        inputRelatedToGroupId,
        inputRelatedToGroupName,
        inputRelatedToPriorityId,
        inputRelatedToPriorityName,
        inputRelatedToSourceId,
        inputRelatedToSourceName,
        inputRelatedToStatusConditionId,
        inputRelatedToStatusConditionName,
        inputRelatedToCloseCloseResult,
        inputRelatedToCloseCloseReasonId,
        inputRelatedToCloseCloseReasonName,
        inputRelatedToRateRating,
        inputRelatedToRateRatingComment,
        inputRelatedToTimingResolvedAt,
        inputRelatedToTimingReactedAt,
        inputRelatedToTimingDifferenceInReaction,
        inputRelatedToTimingDifferenceInResolve,
        inputRelatedToServiceId,
        inputRelatedToServiceName,
        inputRelatedToCommentsPage,
        inputRelatedToCommentsNext,
        inputRelatedToRelatedPage,
        inputRelatedToRelatedNext,
        inputRelatedToLinksPage,
        inputRelatedToLinksNext,
        inputRelatedToFilesPage,
        inputRelatedToFilesNext,
        inputRelatedToSlaId,
        inputRelatedToSlaName,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} etag (etag only)
   * @param {Array<string>} [fields] fields on return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelatedCasesApi
   */
  public deleteRelatedCase(
    etag: string,
    fields?: Array<string>,
    options?: any
  ) {
    return RelatedCasesApiFp(this.configuration)
      .deleteRelatedCase(etag, fields, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The related cases can be obtained bidirectionally as child or parent, but we should consider them from the perspective of the requested case, by inverting their connection type Requested case always a parent and related cases a children
   * @param {string} caseEtag
   * @param {string} [page]
   * @param {string} [size]
   * @param {string} [q]
   * @param {Array<string>} [qin]
   * @param {string} [sort]
   * @param {Array<string>} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelatedCasesApi
   */
  public listRelatedCases(
    caseEtag: string,
    page?: string,
    size?: string,
    q?: string,
    qin?: Array<string>,
    sort?: string,
    fields?: Array<string>,
    options?: any
  ) {
    return RelatedCasesApiFp(this.configuration)
      .listRelatedCases(caseEtag, page, size, q, qin, sort, fields, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} etag (id allowed)
   * @param {Array<string>} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelatedCasesApi
   */
  public locateRelatedCase(
    etag: string,
    fields?: Array<string>,
    options?: any
  ) {
    return RelatedCasesApiFp(this.configuration)
      .locateRelatedCase(etag, fields, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} inputEtag
   * @param {InlineObject2} input
   * @param {Array<string>} [fields] on return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelatedCasesApi
   */
  public updateRelatedCase(
    inputEtag: string,
    input: InlineObject2,
    fields?: Array<string>,
    options?: any
  ) {
    return RelatedCasesApiFp(this.configuration)
      .updateRelatedCase(inputEtag, input, fields, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} inputEtag
   * @param {InlineObject3} input
   * @param {Array<string>} [fields] on return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelatedCasesApi
   */
  public updateRelatedCase2(
    inputEtag: string,
    input: InlineObject3,
    fields?: Array<string>,
    options?: any
  ) {
    return RelatedCasesApiFp(this.configuration)
      .updateRelatedCase2(inputEtag, input, fields, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
